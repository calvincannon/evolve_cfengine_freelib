# Copyright Evolve Thinking ( www.evolvethinking.com ).
# For fresh updates visit:
# https://github.com/evolvethinking/evolve_cfengine_freelib

#
# License
#
# Evolve_freelib.cf is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.  See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.

#
# Introduction
#
# The bundles contained in this library primarily focus on content driven
# policy.  Each such bundle takes csv type delimited parameter file as shown in
# the common bundle efl_c. A record consists of a single line and the required
# fields.
#
# A skeleton bundle is provided for those that wish to create new bundles.

#
# Requirements
# 
# CFEngine Core 3.6.x or higher
# CFEengine standard library

bundle agent efl_skeleton ( ref )
{
   meta:
      "purpose" string => "Skeleton bundle for new bundle authoring";
      "field_0" string => "Context";

   vars:
      "d_raw"
         comment => "Read json file",
         data    => readjson( "${ref}", "512k" );
      "i"
         comment => "Index json data.",
         slist   => getindices( "d_raw" );
      "x"
         comment => "Sub index of pair names to work around bug 2333",
         slist => getindices( "d_raw[0]" );

      "d[${i}][${x}]"
         comment => "Create new array to expand vars. See bug CFE 2333",
         string => "${d_raw[${i}][${x}]}";

      # create references for simple reading.
      "promisee[${i}]"  string => "d[${i}][promisee]";
      "path[${i}]"      string => "d[${i}][path]";
      "class[${i}]"     string => "d[${i}][class]";
      # Call the above variable as ${${class[${f}]}} 
}

bundle common efl_c
{
   meta:
      "purpose" string => "Common variables used by this library";

   vars:
      "cache"
         comment => "Location for agent to cache template and other temp files",
         string  => "/var/cache/cfengine";

      amd_com::
         "policy_servers"
            comment => "Policy servers for remote copies",
            slist   => { "@{ps.policy_servers}" };

      !amd_com::
         "policy_servers"
            comment => "Policy servers for remote copies",
            slist   => { "${sys.policy_hub}" };

      any::
      "localhost"
         comment => "Use when policy server is localhost",
         slist => { "localhost" };

      "class"
         comment => "Regex to extract class name from parameter file name.",
         string  => ".*?-(\w+)\.txt";

      "comment"
         comment => "Comment string in data file.",
         string  => "\s*#[^\n]*";

      "array_delimiter"
         comment => "Field delimiter for CSV data files read by readstringarrayidx",
         string  => "\s*;;\s*";

      "slist_delimiter"
         comment => "Field delimiter for CSV data files read by readstringlist",
         string  => "\s";

      "max_num"
         comment => "Maximum number of lines to read from data file",
         int     => "500";

      "max_bytes"
         comment => "Maximum number of bytes to read from data file.",
         string  => "1M";

      "logdir"
         comment => "Log dir for Delta Reporting logs",
         string => "${sys.workdir}/delta_reporting/log";

      "promise_log"
         comment => "Location for experimental promise outcome log.",
         string  => "${logdir}/promises";

      "udate"
         comment => "Date stamp to match agent output",
         string  => strftime( "localtime", "%Y-%m-%dT%H:%M:%S%z", now() );

      "efl_server_txt"
            comment => "Server access rules parameter file",
# NOTE Access file must be hardcoded because server bundles do not accept arguments.
            string => "${sys.workdir}/inputs/efl_data/bundle_params/efl_server.txt";
}

bundle agent efl_main( ref )
{
   meta:
      "meta_purpose" string => "All policies are called via methods iteration from this bundle.";
      "input" string => "Takes a json file of documents in a list";
# [
#    {
#       "class" : "Context when method is called",
#       "promiser" :  "Method promiser name",
#       "bundle" : "Bundle name",
#       "ifelapsed" : "Ifelapsed number of minutes",
#       "parameter" : "Bundle parameter",
#       "promisee" : "Promisee"
#    },
#    {
#       repeat new document for next method call
#    }
# ]
#
# Documents are processed in the order they appear. Order of elements in each
# document does not matter.

   vars:
      "d_raw"
         comment => "Read json file",
         data    => readjson( "${ref}", "512k" );
      "i"
         comment => "Index json data.",
         slist   => getindices( "d_raw" );
      "x"
         comment => "Sub index of pair names to work around bug 2333",
         slist => getindices( "d_raw[0]" );

      "d[${i}][${x}]"
         comment => "Create new array to expand vars. See bug CFE 2333",
         string => "${d_raw[${i}][${x}]}";

      "${x}[${i}]"
         comment => "Turn into references for simpler reading and editing",
         string => "d[${i}][${x}]";

   methods:
      "methods loop wrapper"
         comment    => "Call wrapper bundle to workaround naked variable bug.",
         handle     => "efl_main_methods_efl_bug2638",
         ifvarclass => "${${class[${i}]}}",
         action     => if_elapsed( "${${ifelapsed[${i}]}}" ),
         usebundle  => efl_bug2638(
            "${${promiser[${i}]}}_${i}",
            "${${promisee[${i}]}}",
            "${${bundle[${i}]}}",
            "${${parameter[${i}]}}"
         );
}

bundle agent efl_bug2638(promiser_name, promisee_name, bundle_name, parameter)
{
   meta:
      "meta_purpose" string => "Workaround for naked variable bug 2638.";
      "bug"          string => "https://cfengine.com/dev/issues/2638";

   methods:
      "${promiser_name}" -> { "${promisee_name}" }
         comment    => "Methods promises described in methods.txt",
         handle     => "efl_bug2638_methods_loop",
         usebundle  => ${bundle_name}( "${parameter}" );
}

bundle agent efl_class_returnszero( ref )
{
   meta:
      "purpose" string => "Define classes using returnszero function.";
      "inputs" string =>> "Takes a json file of documents in a list";
# [
#    {
#       "class"        : "Context that must be true to consider promise.",
#       "class_to_set" : "Class to set if promise evaluates to true.",
#       "command"      : "Command to run",
#       "shell"        : "returnszero shell option: useshell, noshell, or powershell",
#       "zero"         : "Set class if returns zero (yes) or non-zero (no)",
#       "promisee"     : "promisee for documentation"
#    }
# ]

   vars:
      "d_raw"
         comment => "Read json file",
         data    => readjson( "${ref}", "512k" );
      "i"
         comment => "Index json data.",
         slist   => getindices( "d_raw" );
      "x"
         comment => "Sub index of pair names to work around bug 2333",
         slist => getindices( "d_raw[0]" );

      "d[${i}][${x}]"
         comment => "Create new array to expand vars. See bug CFE 2333",
         string => "${d_raw[${i}][${x}]}";

      # create references for simple reading.
      "class[${i}]"        string => "d[${i}][class]";
      "class_to_set[${i}]" string => "d[${i}][promiser]";
      "command[${i}]"      string => "d[${i}][command]";
      "shell[${i}]"        string => "d[${i}][shell]";
      "zero[${i}]"         string => "d[${i}][zero]";
      "promisee[${i}]"     string => "d[${i}][promisee]";

   classes:
      "${${class_to_set[${i}]}}_non_zero" -> { "${${promisee[${i}]}}" }
         comment    => "Does class to set result from zero or non zero return value",
         ifvarclass => "${${class[${i}]}}",
         expression => strcmp( "${${zero[${i}]}}", "no" );

      "${${class_to_set[${i}]}}_zero" -> { "${${promisee[${i}]}}" }
         comment    => "Does class to set result from zero or non zero return value",
         ifvarclass => "${${class[${i}]}}",
         expression => strcmp( "${${zero[${i}]}}", "yes" );

      "${${class_to_set[${i}]}}" -> { "${${promisee[${i}]}}" }
         comment    => "Set class if expression returns non zero",
         ifvarclass => "${${class_to_set[${i}]}}_non_zero",
         scope      => "namespace",
         not        => returnszero( "${${command[${i}]}}", "${${shell[${i}]}}" );

      "${${class_to_set[${i}]}}" -> { "${${promisee[${i}]}}" }
         comment    => "Set class if expression returns zero",
         ifvarclass => "${${class_to_set[${i}]}}_zero",
         scope      => "namespace",
         expression => returnszero( "${${command[${i}]}}", "${${shell[${i}]}}" );
}

bundle agent efl_sysctl_live( ref )
{   
   meta:
      "purpose" string => "Promise live sysctl kernel settings";
      "field_0" string => "Context";
      "field_1" string => "sysctl variable";
      "field_2" string => "sysctl value";
      "field_3" string => "Promisee";

   vars:
      "dim_sysctl"
         comment => "Read data file for parsing.",
         handle  => "efl_sysctl_live_vars_sysctl_promiser",
         int     => readstringarrayidx(
            "sysctl_promiser_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "x"
         comment => "Get index array loaded above.",
         handle  => "efl_sysctl_live_vars_x",
         slist   => getindices( "sysctl_promiser_o" );

      "x2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3" };
      
      "sysctl_promiser[${x}][${x2}]"
         comment => "Work around for bug 2333",
         string => "${sysctl_promiser_o[${x}][${x2}]}";

      "class[${x}]"
         comment => "Turn into reference for simpler reading.",
         string  => "sysctl_promiser[${x}][0]";
      "sysctl_name[${x}]"
         comment => "Turn into reference for simpler reading.",
         string  => "sysctl_promiser[${x}][1]";
      "sysctl_value[${x}]"
         comment => "Turn into reference for simpler reading.",
         string  => "sysctl_promiser[${x}][2]";
      "promisee[${x}]"
         comment => "Turn into reference for simpler reading.",
         string  => "sysctl_promiser[${x}][3]";

      "efl_sysctl_live[${${sysctl_name[${x}]}}]"
         comment    => "Get current live value",
         ifvarclass => "${${class[${x}]}}",
         string     => execresult(
            "${paths.path[sysctl]} -n ${${sysctl_name[${x}]}} |${paths.path[tr]} -d '\\n' | ${paths.path[tr]} '[:space:]' ' '",
            "useshell"
         );

   classes:
      "set_live_sysctl_${${sysctl_name[${x}]}}"
         comment    => "Set class if live sysctl variable not equal to promised value",
# This class may be falsely set due to bug 3577. A work around is in commands below.
         ifvarclass => "${${class[${x}]}}",
         not        => strcmp( "${${sysctl_value[${x}]}}", "${efl_sysctl_live[${${sysctl_name[${x}]}}]}" );

      "${${sysctl_name[${x}]}}=${${sysctl_value[${x}]}}_handle_efl_sysctl_live_classes_ok_kept"
         comment    => "Set class if live sysctl variable not equal to promised value",
         handle     => "efl_sysctl_live_classes_ok",
         scope      => "namespace",
         ifvarclass => "${${class[${x}]}}",
         expression => strcmp( "${${sysctl_value[${x}]}}", "${efl_sysctl_live[${${sysctl_name[${x}]}}]}" );

   commands:
      "${paths.path[sysctl]} -w ${${sysctl_name[${x}]}}='${${sysctl_value[${x}]}}'" -> { "${${promisee[${x}]}}" }
         comment    => "Set live sysctl variable",
         handle     => "efl_sysctl_live_commands_sysctl_w",
         classes    => efl_rkn( "${paths.path[sysctl]} -w ${${sysctl_name[${x}]}}='${${sysctl_value[${x}]}}'", "efl_sysctl_live_commands_sysctl_w" ),
         action     => efl_delta_reporting( "efl_sysctl_live_commands_sysctl_w", "${paths.path[sysctl]} -w ${${sysctl_name[${x}]}}='${${sysctl_value[${x}]}}'", "${${promisee[${x}]}}", "1" ),
# This and statement is due to CFEngine bug 3577. When the bug is fixed remove {class}.
         ifvarclass => and( "${${class[${x}]}}",  canonify( "set_live_sysctl_${${sysctl_name[${x}]}}" ) ), 
         contain    => in_shell_and_silent;

   reports:
      delta_reporting::
         "efl_sysctl_live_classes_ok ;; ${${sysctl_name[${x}]}}=${${sysctl_value[${x}]}} ;; ${${promisee[${x}]}}" -> { "${${promisee[${x}]}}" }
            handle         => "efl_sysctl_live_reports_log_promises",
            ifvarclass     => canonify( "${${sysctl_name[${x}]}}=${${sysctl_value[${x}]}}_handle_efl_sysctl_live_classes_ok_kept" ),
            report_to_file => "${efl_c.promise_log}";
}

bundle agent efl_sysctl_conf_file( ref )
{
   meta:
      "purpose" string => "Promise live sysctl.conf.";
      "field_0" string => "Context";
      "field_1" string => "sysctl variable";
      "field_2" string => "sysctl value";
      "field_3" string => "Promisee";

   vars:
      "sysctl_conf"  string => "/etc/sysctl.conf";

      "dim_sysctl"
         comment => "Read data file for parsing.",
         handle  => "efl_sysctl_conf_file_vars_sysctl",
         int     => readstringarrayidx(
            "sysctl_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "x"
         comment => "Get index array loaded above.",
         handle  => "efl_sysctl_conf_file_vars_x",
         slist   => getindices( "sysctl_o" );

      "x2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3" };
      
      "sysctl[${x}][${x2}]"
         comment => "Work around for bug 2333",
         string => "${sysctl_o[${x}][${x2}]}";

   files:
      "${sysctl_conf}" -> { "Provisioning" }
         comment       => "Promise whole contents of sysctl.conf",
         handle        => "efl_sysctl_conf_file_files_contents",
         classes       => efl_rkn( "${sysctl_conf}", "efl_sysctl_conf_file_files_contents" ),
         action        => efl_delta_reporting( "efl_sysctl_conf_file_files_contents", "${sysctl_conf}", "Harending", "1" ),
         create        => "true",
         edit_defaults => empty,
         edit_line     => el_efl_sysctl_conf_file( "efl_sysctl_conf_file.sysctl" );

      "${sysctl_conf}" -> { "Provisioning" }
         handle  => "efl_sysctl_conf_file_files_perms",
         classes => efl_rkn( "${sysctl_conf}", "efl_sysctl_conf_file_files_perms" ),
         action  => efl_delta_reporting( "efl_sysctl_conf_file_files_perms", "${sysctl_conf}", "Harending", "1" ),
         perms   => mog( "644", "root", "root" );
}

bundle edit_line el_efl_sysctl_conf_file( ref )
{   
   vars:
      "x"
         comment => "Get index array loaded above.",
         handle  => "el_efl_sysctl_conf_file_vars_x",
         slist   => getindices( "${ref}" );

      "class[${x}]"
         comment => "Turn into reference for simpler reading.",
         string  => "${ref}[${x}][0]";
      "sysctl_name[${x}]"
         comment => "Turn into reference for simpler reading.",
         string  => "${ref}[${x}][1]";
      "sysctl_value[${x}]"
         comment => "Turn into reference for simpler reading.",
         string  => "${ref}[${x}][2]";
      "promisee[${x}]"
         comment => "Turn into reference for simpler reading.",
         string  => "${ref}[${x}][3]";

   insert_lines:
      "${${sysctl_name[${x}]}} = ${${sysctl_value[${x}]}}" -> { "${${promisee[${x}]}}" }
         handle     => "el_efl_sysctl_conf_file_insert_lines",
# TODO classes and actions do not seem to work in this bundle type.
         classes    => efl_rkn( "${${sysctl_name[${x}]}} = ${${sysctl_value[${x}]}}", "el_efl_sysctl_conf_file_insert_lines" ),
         action     => efl_delta_reporting( "el_efl_sysctl_conf_file_insert_lines", "${${sysctl_name[${x}]}} = ${${sysctl_value[${x}]}}", "${${promisee[${x}]}}", "1" ),
         ifvarclass => "${${class[${x}]}}";
}

bundle agent efl_command ( ref )
{
   meta:
      "purpose" string => "Run given command if context is true.";
      "input" string => "Takes a json file of documents in a list";
# [
#    {
#       "class" : "Context when to promise command",
#       "command" :  "command to run",
#       "useshell" : "useshell or noshell",
#       "module" : "yes or no",
#       "ifelapsed" : "Ifelapsed number of minutes",
#       "promisee" : "Promisee"
#    },
#    {
#       repeat new document for next command 
#    }
# ]
#
# Documents are processed in the order they appear. Order of elements in each
# document does not matter.

   vars:
      "d_raw"
         comment => "Read json file",
         data    => readjson( "${ref}", "512k" );
      "i"
         comment => "Index json data.",
         slist   => getindices( "d_raw" );
      "x"
         comment => "Sub index of pair names to work around bug 2333",
         slist => getindices( "d_raw[0]" );

      "d[${i}][${x}]"
         comment => "Create new array to expand vars. See bug CFE 2333",
         string => "${d_raw[${i}][${x}]}";

      "${x}[${i}]"
         comment => "Turn into references for simpler reading and editing",
         string => "d[${i}][${x}]";

   commands:
      "${${command[${i}]}}" -> { "${${promisee[${i}]}}" }
         comment    => "Run desired command",
         handle     => "efl_command_commands",
         ifvarclass => "${${class[${i}]}}",
         contain    => contain_efl_command( "${${useshell[${i}]}}" ),
         module     => "${${module[${i}]}}",
         classes    => efl_rkn( "${${command[${i}]}}", "efl_command_commands" ),
         action     => efl_delta_reporting( "efl_command_commands", "${${command[${i}]}}", "${${promisee[${i}]}}", "${${ifelapsed[${i}]}}" );
}

body contain contain_efl_command ( useshell )
{
   useshell => "${useshell}";
}

bundle agent efl_link ( ref )
{
   meta:
      "purpose" string => "Link files if context is true.";
      "field_0" string => "Context";
      "field_1" string => "Link promiser";
      "field_2" string => "Link target";
      "field_3" string => "Link type";
      "field_4" string => "Promisee";

   vars:
      "dim_link"
         comment => "Read data file for parsing.",
         handle  => "efl_link_vars_files",
         int     => readstringarrayidx(
            "link_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "l"
         comment => "Get index array loaded above.",
         handle  => "efl_link_vars_f",
         slist   => getindices( "link_o" );

      "l2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4" };

      "link[${l}][${l2}]"
         comment => "Work around for bug 2333",
         string => "${link_o[${l}][${l2}]}";

      "class[${l}]"
         comment => "Turn into reference for simpler reading.",
         string  => "link[${l}][0]";
      "link[${l}]"
         comment => "Turn into reference for simpler reading.",
         string  => "link[${l}][1]";
      "target[${l}]"
         comment => "Turn into reference for simpler reading.",
         string  => "link[${l}][2]";
      "type[${l}]"
         comment => "Turn into reference for simpler reading.",
         string  => "link[${l}][3]";
      "promisee[${l}]"
         comment => "Turn into reference for simpler reading.",
         string  => "link[${l}][4]";

   files:
      "${${link[${l}]}}" -> { "${${promisee[${l}]}}" }
         comment           => "Make link if class is true",
         handle            => "efl_link_files_target",
         ifvarclass        => "${${class[${l}]}}",
         move_obstructions => 'true',
         classes           => efl_rkn( "${${link[${l}]}}", "efl_link_files_target" ),
         action            => efl_delta_reporting( "efl_link_files_target", "${${link[${l}]}}", "${${promisee[${l}]}}", "1" ),
         link_from         => efl_source_type( "${${target[${l}]}}", "${${type[${l}]}}" );
}

body link_from efl_source_type ( source, type )
{
   source         => "${source}";
   link_type      => "${type}";
   when_no_source => "force";
}

bundle agent efl_delete_files ( ref )
{
   meta:
      "purpose" string => "Delete files that match the given criteria.";
      "field_0" string => "Context";
      "field_1" string => "Files promiser";
      "field_2" string => "Recurse no/#/inf";
      "field_3" string => "Leaf regex";
      "field_4" string => "Negative match yes/no";
      "field_5" string => "File age in days";
      "field_6" string => "Promisee";

   vars:
      "dim_files"
         comment => "Read data file for parsing.",
         handle  => "efl_delete_files_vars_files",
         int     => readstringarrayidx(
            "files_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "f"
         comment => "Get index array loaded above.",
         handle  => "efl_delete_files_vars_f",
         slist   => getindices( "files_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6" };

      "files[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${files_o[${f}][${f2}]}";

      "class[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][0]";
      "file[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][1]";
      "recurse[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][2]";
      "leaf[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][3]";
      "negate[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][4]";
      "age[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][5]";
      "promisee[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][6]";

   classes:
         "${${file[${f}]}}_isdir_${f}" -> { "${${promisee[${f}]}}" }
            comment    => "Determine if promiser is a directory",
            ifvarclass => "${${class[${f}]}}",
            expression => isdir( "${${file[${f}]}}" );

         "${${file[${f}]}}_negative_match_${f}" -> { "${${promisee[${f}]}}" }
            comment    => "Determine if negated match is desired.",
            ifvarclass => "${${class[${f}]}}",
            expression => strcmp( "yes", "${${negate[${f}]}}" );

   files:
      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment      => "Delete files recursively",
         handle       => "efl_delete_files_files_isdir",
         classes      => efl_rkn( "${${file[${f}]}}", "efl_delete_files_files_isdir" ),
         action       => efl_delta_reporting( "efl_delete_files_files_isdir", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass   => and(
            canonify( "${${file[${f}]}}_isdir_${f}" ),
            not( canonify( "${${file[${f}]}}_negative_match_${f}" ))),
         depth_search => recurse( "${${recurse[${f}]}}" ),
         file_select  => name_age( "${${leaf[${f}]}}", "${${age[${f}]}}" ),
         delete       => tidy;

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment      => "Delete files",
         handle       => "efl_delete_files_files_single",
         classes      => efl_rkn( "${${file[${f}]}}", "efl_delete_files_files_single" ),
         action       => efl_delta_reporting( "efl_delete_files_files_single", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass   => and(
            canonify( "${${class[${f}]}}" ),
            not( canonify( "${${file[${f}]}}_isdir_${f}" )),
            not( canonify( "${${file[${f}]}}_negative_match_${f}" ))),
         file_select  => name_age( "${${leaf[${f}]}}", "${${age[${f}]}}" ),
         delete       => tidy;

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment      => "Delete files recursively excluding leaf name.",
         handle       => "efl_delete_files_files_isdir_negative",
         classes      => efl_rkn( "${${file[${f}]}}", "efl_delete_files_files_isdir_negative" ),
         action       => efl_delta_reporting( "efl_delete_files_files_isdir_negative", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass   => and(
            canonify( "${${file[${f}]}}_isdir_${f}" ),
            canonify( "${${file[${f}]}}_negative_match_${f}" )),
         depth_search => recurse( "${${recurse[${f}]}}" ),
         file_select  => name_age_negate( "${${leaf[${f}]}}", "${${age[${f}]}}" ),
         delete       => tidy;

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment      => "Delete files, excluding leaf name",
         handle       => "efl_delete_files_files_single_negative",
         classes      => efl_rkn( "${${file[${f}]}}", "efl_delete_files_files_single_negative" ),
         action       => efl_delta_reporting( "efl_delete_files_files_single_negative", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass   => and(
            not( canonify( "${${file[${f}]}}_isdir_${f}" )),
            canonify( "${${file[${f}]}}_negative_match_${f}" )),
         file_select  => name_age_negate( "${${leaf[${f}]}}", "${${age[${f}]}}" ),
         delete       => tidy;
}

body file_select name_age_negate(name,days)
{
leaf_name   => { "$(name)" };
mtime       => irange(0,ago(0,0,"$(days)",0,0,0));
file_result => "mtime.!leaf_name";
}

bundle agent efl_global_slists( ref )
{
   meta:
      "purpose" string => "Set slist type variable when class is true.";
      "field_0" string => "Context";
      "field_1" string => "Variable name";
      "field_2" string => "csv inline list or path to external file where file format is one list element per line.";
		"field_4" string => "random shuffle list (r), or determistic shuffle (d), or normal (n)";
      "field_3" string => "Promisee";

   vars:
      "dim_slist"
         comment => "Read data file for parsing.",
         handle  => "efl_global_slists_vars_files",
         int     => readstringarrayidx(
            "slist_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "s"
         comment => "Get index array loaded above.",
         handle  => "efl_global_slists_vars_s",
         slist   => getindices( "slist_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4" };

      "slist[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string  => "${slist_o[${s}][${s2}]}";

      "class[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "slist[${s}][0]";
      "name[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "slist[${s}][1]";
      "list_data[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "slist[${s}][2]";
      "shuffle[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "slist[${s}][3]";
      "promisee[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "slist[${s}][4]";

		"seed" int => randomint( "1", "999999" );

		"pre_shuffle_${${name[${s}]}}"
			comment => "Get list from external file",
			ifvarclass => and( "parse_list_file_${s}", "${${class[${s}]}}"),
			slist => readstringlist(
				"${${list_data[${s}]}}",
				"\s*#[^\n]*",
				"\n",
				"500",
				"1M"
				);

		"pre_shuffle_${${name[${s}]}}"
			comment    => "Get list from external file",
			ifvarclass => and( "parse_csv_list_${s}" , "${${class[${s}]}}"),
			slist      => splitstring( "${${list_data[${s}]}}", "\s*,\s*", "500" );

		"${${name[${s}]}}"
			comment    => "no shuffle list",
			ifvarclass => "n_shuffle_${s}",
			slist      => { "@{pre_shuffle_${${name[${s}]}}}" };

		"${${name[${s}]}}"
			comment    => "random shuffle list",
			ifvarclass => "r_shuffle_${s}",
			slist      => shuffle( "pre_shuffle_${${name[${s}]}}", "${seed}" );

		"${${name[${s}]}}"
			comment    => "deterministic shuffle list",
			ifvarclass => "d_shuffle_${s}",
			slist      => shuffle( "pre_shuffle_${${name[${s}]}}", "${sys.uqhost}" );

	classes:
		"parse_list_file_${s}"
			comment    => "Determine if list_data points to a file",
			ifvarclass => "${${class[${s}]}}",
			expression => fileexists( "${${list_data[${s}]}}" );

		"parse_csv_list_${s}"
			comment    => "If no file then assume data is inline csv",
			ifvarclass => "${${class[${s}]}}",
			not        => fileexists( "${${list_data[${s}]}}" );

	  "d_shuffle_${s}"
			comment    => "Determnistically random list.",
			ifvarclass => "${${class[${s}]}}",
			expression => strcmp( "${${shuffle[${s}]}}", "d" );

	  "r_shuffle_${s}"
			comment    => "Random list.",
			ifvarclass => "${${class[${s}]}}",
			expression => strcmp( "${${shuffle[${s}]}}", "r" );

	  "n_shuffle_${s}"
			comment    => "Normal list without random.",
			ifvarclass => "${${class[${s}]}}",
			expression => strcmp( "${${shuffle[${s}]}}", "n" );

}

bundle agent efl_global_strings ( ref )
{
   meta:
      "purpose" string => "Set string type variable when class is true.";
      "field_0" string => "Context";
      "field_1" string => "Variable name";
      "field_2" string => "Variable value";
      "field_3" string => "Promisee";

   vars:
      "dim_string"
         comment => "Read data file for parsing.",
         handle  => "efl_global_strings_vars_files",
         int     => readstringarrayidx(
            "string_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "s"
         comment => "Get index array loaded above.",
         handle  => "efl_global_strings_vars_s",
         slist   => getindices( "string_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3" };

      "string[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string => "${string_o[${s}][${s2}]}";

      "class[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "string[${s}][0]";
      "name[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "string[${s}][1]";
      "value[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "string[${s}][2]";
      "promisee[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "string[${s}][3]";

      "${${name[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment    => "Define variable if class is true",
         ifvarclass => "${${class[${s}]}}",
         string     => "${${value[${s}]}}";
}

bundle agent efl_class_cmd_regcmp( ref )
{
   meta:
      "purpose" string => "Set global class if the given command output matches regex.";
      "wanring" string => "Commands in classes and variables are expensive";
      "field_0" string => "Context";
      "field_1" string => "Class promiser to set";
      "field_2" string => "Class expression is 'not' rather than 'expression'";
      "field_3" string => "command to run";
      "field_4" string => "useshell or noshell";
      "field_5" string => "anchored regex to match command output";
      "field_6" string => "Promisee";

   vars:
      "dim_class"
         comment => "Read data file for parsing.",
         handle  => "efl_class_cmd_regcmp_vars_files",
         int     => readstringarrayidx(
            "class_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "c"
         comment => "Get index array loaded above.",
         handle  => "efl_class_cmd_regcmp_vars_c",
         slist   => getindices( "class_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6" };

      "class[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${class_o[${c}][${c2}]}";

      "context[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][0]";
      "class_to_set[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][1]";
      "not[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][2]";
      "command[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][3]";
      "useshell[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][4]";
      "regex[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][5]";
      "promisee[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][6]";

      "cmd_output_${c}" -> { "${${promisee[${c}]}}" }
         comment    => "Capture commmand output",
         ifvarclass => "${${context[${c}]}}",
         string     => execresult( "${${command[${c}]}}", "${${useshell[${c}]}}" );

   classes:
      "${${class_to_set[${c}]}}_not" -> { "${${promisee[${c}]}}" }
         comment    => "Use not rather than expression",
         ifvarclass => "${${context[${c}]}}",
         expression => strcmp( "${${not[${c}]}}", "yes" );

      "${${class_to_set[${c}]}}_exp" -> { "${${promisee[${c}]}}" }
         comment    => "Use expression",
         ifvarclass => "${${context[${c}]}}",
         expression => strcmp( "${${not[${c}]}}", "no" );

      "${${class_to_set[${c}]}}" -> { "${${promisee[${c}]}}" }
         comment    => "Set class if command output matches the anchored regex.",
         scope      => "namespace",
         ifvarclass => "${${class_to_set[${c}]}}_exp",
         expression => regcmp( "${${regex[${c}]}}", "${cmd_output_${c}}" );

      "${${class_to_set[${c}]}}" -> { "${${promisee[${c}]}}" }
         comment    => "Set class if command output does not match the anchored regex.",
         scope      => "namespace",
         ifvarclass => "${${class_to_set[${c}]}}_not",
         not        => regcmp( "${${regex[${c}]}}", "${cmd_output_${c}}" );
}

bundle agent efl_class_expression( ref )
{
   meta:
      "purpose" string => "Set global class if the given class expression is true.";
      "field_0" string => "Class promiser";
      "field_1" string => "Class expression";
      "field_2" string => "Promisee";

   vars:
      "dim_class"
         comment => "Read data file for parsing.",
         handle  => "efl_class_expression_vars_files",
         int     => readstringarrayidx(
            "class_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "c"
         comment => "Get index array loaded above.",
         handle  => "efl_class_expression_vars_c",
         slist   => getindices( "class_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2" };

      "class[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${class_o[${c}][${c2}]}";

      "class_to_set[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][0]";
      "class_expression[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][1]";
      "promisee[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][2]";

   classes:
      "${${class_to_set[${c}]}}" -> { "${${promisee[${c}]}}" }
         comment    => "Set class if expression is true.",
         scope      => "namespace",
         expression => "${${class_expression[${c}]}}";
}

bundle agent efl_class_classmatch( ref )
{
   meta:
      "purpose" string => "Set global class if the given regex matches a defined class";
      "field_0" string => "Class promiser";
      "field_1" string => "Regex for the function classmatch";
      "field_2" string => "Promisee";

   vars:
      "dim_class"
         comment => "Read data file for parsing.",
         handle  => "efl_class_classmatch_vars_files",
         int     => readstringarrayidx(
            "class_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "c"
         comment => "Get index array loaded above.",
         handle  => "efl_class_classmatch_vars_c",
         slist   => getindices( "class_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2" };

      "class[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${class_o[${c}][${c2}]}";

      "class_to_set[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][0]";
      "regex[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][1]";
      "promisee[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][2]";

   classes:
      "${${class_to_set[${c}]}}" -> { "${${promisee[${c}]}}" }
         comment    => "Set class if classmatch function returns true.",
         scope      => "namespace",
         expression => classmatch( "${${regex[${c}]}}" );
}

bundle agent efl_class_iprange( ref )
{
   meta:
      "purpose" string => "Set global class if host IP is within the given range";
      "field_0" string => "Class promiser";
      "field_1" string => "IP address range in the format of the iprange function.";
      "field_2" string => "Promisee";

   vars:
      "dim_class"
         comment => "Read data file for parsing.",
         handle  => "efl_class_iprange_vars_files",
         int     => readstringarrayidx(
            "class_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "c"
         comment => "Get index array loaded above.",
         handle  => "efl_class_iprange_vars_c",
         slist   => getindices( "class_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2" };

      "class[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${class_o[${c}][${c2}]}";

      "class_to_set[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][0]";
      "ip_range[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][1]";
      "promisee[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][2]";

   classes:
      "${${class_to_set[${c}]}}" -> { "${${promisee[${c}]}}" }
         comment    => "Set class if iprange function returns true.",
         scope      => "namespace",
         expression => iprange( "${${ip_range[${c}]}}" );
}

bundle agent efl_class_hostname( ref )
#
# Reads parameter file in the form of <name>-<class>.txt.
# the file contains a list of unqualified hostnames separated by white space.
# If ${sys.uqhost} matches any name in the list <class> is defined.
{
   meta:
      "purpose" string => "Set global class if list item matches hostname";
      "field_0" string => "unqualified hostname";

   classes:
      "check_hostnames_${ref}"
         comment    => "Get class name from filename",
         expression => regextract( "${efl_c.class}", "${ref}", "class" );
      
      "${class[1]}"
         comment    => "Set class if unqualified hostname matches any list element.",
         scope      => "namespace",
         ifvarclass => canonify( "check_hostnames_${ref}" ),
         expression => regline( "${sys.uqhost}", "${ref}" );
}

bundle agent efl_copy_files ( ref )
{
   meta:
      "purpose" string => "Copy files";
      "field_0" string => "Context";
      "field_1" string => "File promiser. A trailing /. indicates a directory for recursive copy.";
      "field_2" string => "leaf regex";
      "field_3" string => "File source";
      "field_4" string => "Server";
      "field_5" string => "Encrypt transfer";
      "field_6" string => "file mode";
      "field_7" string => "file owner";
      "field_8" string => "file group";
      "field_9" string => "Promisee";

   vars:
      "dim_files"
         comment => "Read data file for parsing.",
         handle  => "efl_copy_files_vars_files",
         int     => readstringarrayidx(
            "files_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "f"
         comment => "Get index array loaded above.",
         handle  => "efl_copy_files_vars_f",
         slist   => getindices( "files_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" };

      "files[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${files_o[${f}][${f2}]}";

      "class[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][0]";
      "file[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][1]";
      "leaf[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][2]";
      "source[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][3]";
      "server[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][4]";
      "encrypt[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][5]";
      "mode[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][6]";
      "owner[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][7]";
      "group[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][8]";
      "promisee[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][9]";

   classes:
      "recurse_${${file[${f}]}}_${f}"
         comment    => "Set if promiser is a directory",
         ifvarclass => "${${class[${f}]}}",
         expression => regcmp( ".+/\.", "${${file[${f}]}}" );
      
   files:
      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Create promiser directory",
         ifvarclass => canonify( "recurse_${${file[${f}]}}_${f}" ),
         create     => 'true';

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Copy a single file",
         handle     => "efl_copy_files_remote_single",
         create     => 'true',
         classes    => efl_rkn( "${${file[${f}]}}", "efl_copy_files_remote_single" ),
         action     => efl_delta_reporting( "efl_copy_files_remote_single", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass => and( "${${class[${f}]}}", not(  canonify( "recurse_${${file[${f}]}}_${f}" ) ) ),
         copy_from  => efl_cpf( "${${source[${f}]}}", "@{${${server[${f}]}}}", "${${encrypt[${f}]}}" );

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment      => "Copy and recurse",
         handle       => "efl_copy_files_remove_recurse",
         create       => 'true',
         classes      => efl_rkn( "${${file[${f}]}}", "efl_copy_files_remove_recurse" ),
         action       => efl_delta_reporting( "efl_copy_files_remove_recurse", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass   => and( "${${class[${f}]}}", canonify( "recurse_${${file[${f}]}}_${f}" ) ),
         depth_search => recurse( "inf" ),
         file_select  => by_name( "${${leaf[${f}]}}" ),
         copy_from    => efl_cpf( "${${source[${f}]}}", "@{${${server[${f}]}}}", "${${encrypt[${f}]}}" );

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Promise permissions and ownership",
         handle     => "efl_copy_files_single_perms",
         classes    => efl_rkn( "${${file[${f}]}}", "efl_copy_files_single_perms" ),
         action     => efl_delta_reporting( "efl_copy_files_single_perms", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass => and( "${${class[${f}]}}", not( canonify( "recurse_${${file[${f}]}}_${f}" ) ) ),
         perms      => mog( "${${mode[${f}]}}", "${${owner[${f}]}}", "${${group[${f}]}}" );

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment      => "Promise permissions and ownership",
         handle       => "efl_copy_files_recurse_perms",
         classes      => efl_rkn( "${${file[${f}]}}", "efl_copy_files_recurse_perms" ),
         action       => efl_delta_reporting( "efl_copy_files_recurse_perms", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass   => and( "${${class[${f}]}}", canonify( "recurse_${${file[${f}]}}_${f}" ) ),
         depth_search => recurse( "inf" ),
         file_select  => by_name( "${${leaf[${f}]}}" ),
         perms        => mog( "${${mode[${f}]}}", "${${owner[${f}]}}", "${${group[${f}]}}" );
}

body copy_from efl_cpf(from, server, encrypt)
{
   servers     => { "${server}" };
   source      => "${from}";
   encrypt     => "${encrypt}";
   compare     => "digest";
}

bundle agent efl_packages( ref )
{
   meta:
      "purpose" string => "Promises packages using generic method.";
      "field_0" string => "Context";
      "field_1" string => "Package policy";
      "field_2" string => "Package name regex";
      "field_3" string => "version string";
      "field_4" string => "arch, '*' seems to work to imply any arch";
      "field_5" string => "promisee";
      "ReadMe"  string => "Specify a version of '0' when version does not matter.";

   vars:
      "dim_pkg"
         comment => "Read data file for parsing.",
         handle  => "efl_packages_vars_files",
         int     => readstringarrayidx(
            "pkg_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "p"
         comment => "Get index array loaded above.",
         handle  => "efl_packages_vars_p",
         slist   => getindices( "pkg_o" );

      "p2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5" };

      "pkg[${p}][${p2}]"
         comment => "Work around for bug 2333",
         string => "${pkg_o[${p}][${p2}]}";

      "class[${p}]"
         comment => "Turn into reference for simpler reading.",
         string  => "pkg[${p}][0]";
      "policy[${p}]"
         comment => "Turn into reference for simpler reading.",
         string  => "pkg[${p}][1]";
      "name[${p}]"
         comment => "Turn into reference for simpler reading.",
         string  => "pkg[${p}][2]";
      "version[${p}]"
         comment => "Turn into reference for simpler reading.",
         string  => "pkg[${p}][3]";
      "arch[${p}]"
         comment => "Turn into reference for simpler reading.",
         string  => "pkg[${p}][4]";
      "promisee[${p}]"
         comment => "Turn into reference for simpler reading.",
         string  => "pkg[${p}][5]";

   classes:
      "do not specify version ${${name[${p}]}}_${${version[${p}]}}"
         comment    => "If version is '0' then do not specify version string",
         expression => strcmp( "${${version[${p}]}}", "0" );

   packages:
      "${${name[${p}]}}" -> { "${${promisee[${p}]}}" }
         comment               => "Promise package without version.",
         handle                => "efl_packages_packages_generic_no_version",
         classes               => efl_rkn( "${${name[${p}]}}", "efl_packages_packages_generic_no_version" ),
         action                => efl_delta_reporting( "efl_packages_packages_generic_no_version", "${${name[${p}]}}", "${${promisee[${p}]}}", "1" ),
         ifvarclass            => and(
            canonify( "do not specify version ${${name[${p}]}}_${${version[${p}]}}" ),
            "${${class[${p}]}}"
         ),
         package_policy        => "${${policy[${p}]}}",
         package_method        => generic,
         package_architectures => { "${${arch[${p}]}}" };

      "${${name[${p}]}}" -> { "${${promisee[${p}]}}" }
         comment               => "Promise package with version.",
         handle                => "efl_packages_packages_generic_version",
         classes               => efl_rkn( "${${name[${p}]}}", "efl_packages_packages_generic_version" ),
         action                => efl_delta_reporting( "efl_packages_packages_generic_version", "${${name[${p}]}}", "${${promisee[${p}]}}", "1" ),
         ifvarclass            => and(
            not( canonify( "do not specify version ${${name[${p}]}}_${${version[${p}]}}" ) ),
            "${${class[${p}]}}"
         ),
         package_policy        => "${${policy[${p}]}}",
         package_method        => generic,
         package_version       => "${${version[${p}]}}",
         package_architectures => { "${${arch[${p}]}}" };
}

bundle agent efl_start_service ( ref )
{
   meta:
      "purpose" string => "Start serivce with process and restart command.";
      "field_0" string => "Context";
      "field_1" string => "Process regex";
      "field_2" string => "Restart command";
      "field_3" string => "Promisee";

   vars:
      "dim_svc"
         comment => "Read data file for parsing.",
         handle  => "efl_start_service_vars_files",
         int     => readstringarrayidx(
            "svc_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "s"
         comment => "Get index array loaded above.",
         handle  => "efl_start_service_vars_s",
         slist   => getindices( "svc_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3" };

      "svc[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string => "${svc_o[${s}][${s2}]}";

      "class[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][0]";
      "process[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][1]";
      "command[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][2]";
      "promisee[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][3]";

   processes:
      "${${process[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment        => "Promise process is running",
         handle         => "efl_start_service_processes_proc",
         process_select => by_command( "${${process[${s}]}}" ),
         classes        => efl_rkn( "${${process[${s}]}}", "efl_start_service_processes_proc" ),
         action         => efl_delta_reporting( "efl_start_service_processes_proc", "${${process[${s}]}}", "${${promisee[${s}]}}", "1" ),
         ifvarclass     => "${${class[${s}]}}",
         restart_class  => canonify( "efl_start_service_command_${${process[${s}]}}" );

   commands:
      "${${command[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment    => "Restart service is required.",
         handle     => "efl_start_service_commands_restart",
         classes    => efl_rkn( "${${command[${s}]}}", "efl_start_service_commands_restart" ),
         action     => efl_delta_reporting( "efl_start_service_commands_restart", "${${command[${s}]}}", "${${promisee[${s}]}}", "1" ),
         contain    => in_shell_and_silent,
         ifvarclass => canonify( "efl_start_service_command_${${process[${s}]}}" );
}

bundle agent efl_service ( ref )
{
   meta:
      "purpose"  string => "Promise serivce with file, process, and restart command.";
      "field_0"  string => "Context";
      "field_1"  string => "Process regex";
      "field_2"  string => "Configuration file promiser";
      "field_3"  string => "Configuration file source";
      "field_4"  string => "Source server, as list without syntax: efl_c.policy_servers";
      "field_5"  string => "Template file yes/no";
      "field_6"  string => "Encrypted copy yes/now";
      "field_7"  string => "Configuration file mode";
      "field_8"  string => "Configuration file owner";
      "field_9"  string => "Configuration file group";
      "field_10" string => "Restart command";
      "field_11" string => "Promisee";

   vars:
      "dim_svc"
         comment => "Read data file for parsing.",
         handle  => "efl_service_vars_files",
         int     => readstringarrayidx(
            "svc_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "s"
         comment => "Get index array loaded above.",
         handle  => "efl_service_vars_s",
         slist   => getindices( "svc_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11" };

      "svc[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string => "${svc_o[${s}][${s2}]}";

      "class[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][0]";
      "process[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][1]";
      "config_file[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][2]";
      "source_file[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][3]";
      "server[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][4]";
      "template[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][5]";
      "encrypt[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][6]";
      "mode[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][7]";
      "user[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][8]";
      "group[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][9]";
      "command[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][10]";
      "promisee[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][11]";

   classes:
      "${${source_file[${s}]}}_is_not_a_template" 
         comment    => "Is configuration file a template?",
         ifvarclass => "${${class[${s}]}}",
         expression => strcmp( "${${template[${s}]}}", "no" );

      "${${source_file[${s}]}}_is_a_template"
         comment    => "Is configuration file a template?",
         ifvarclass => "${${class[${s}]}}",
         expression => strcmp( "${${template[${s}]}}", "yes" );

   files:
      "${efl_c.cache}/${${config_file[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment    => "Cache the source file",
         handle     => "efl_service_files_cache",
         classes    => efl_rkn( "${efl_c.cache}/${${config_file[${s}]}}", "efl_service_svc_cache" ),
         action     => efl_delta_reporting( "efl_service_svc_cache", "${efl_c.cache}/${${config_file[${s}]}}", "${${promisee[${s}]}}", "1" ),
         ifvarclass => "${${class[${s}]}}",
         create     => "true",
         perms      => mog(
            "${${mode[${s}]}}",
            "${${user[${s}]}}",
            "${${group[${s}]}}"   
            ),
         copy_from  => efl_cpf( "${${source_file[${s}]}}", "@{${${server[${s}]}}}", "${${encrypt[${s}]}}" );

      "${${config_file[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment    => "Promise contents of configuration file",
         handle     => "efl_service_files_config",
         classes    => efl_rkn( "${${config_file[${s}]}}", "efl_service_files_config" ),
         action     => efl_delta_reporting( "efl_service_files_config", "${${config_file[${s}]}}", "${${promisee[${s}]}}", "1" ),
         ifvarclass => canonify( "${${source_file[${s}]}}_is_not_a_template" ),
         create     => "true",
         copy_from  => efl_cpf( "${efl_c.cache}/${${config_file[${s}]}}", "localhost", "${${encrypt[${s}]}}" );

      "${${config_file[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment       => "Promise contents of configurationn file from template",
         handle        => "efl_service_files_config_template",
         classes       => efl_rkn( "${${config_file[${s}]}}", "efl_service_files_config_template" ),
         action        => efl_delta_reporting( "efl_service_files_config_template", "${${config_file[${s}]}}", "${${promisee[${s}]}}", "1" ),
         create        => "true",
         edit_defaults => empty,
         ifvarclass    => canonify( "${${source_file[${s}]}}_is_a_template" ),
         edit_template => "${efl_c.cache}/${${config_file[${s}]}}";

      "${${config_file[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment    => "Promise permissions of configuration file",
         handle     => "efl_service_files_config_template_permissions",
         classes    => efl_rkn( "${${config_file[${s}]}}", "efl_service_files_config_template_permissions" ),
         action     => efl_delta_reporting( "efl_service_files_config_template_permissions", "${${config_file[${s}]}}", "${${promisee[${s}]}}", "1" ),
         ifvarclass => "${${class[${s}]}}",
         perms      => mog(
            "${${mode[${s}]}}",
            "${${user[${s}]}}",
            "${${group[${s}]}}"   
            );

   processes:
      "${${process[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment        => "Promise process is running",
         handle         => "efl_service_processes_proc",
         classes        => efl_rkn( "${${process[${s}]}}", "efl_service_processes_proc" ),
         action         => efl_delta_reporting( "efl_service_processes_proc", "${${process[${s}]}}", "${${promisee[${s}]}}", "1" ),
         process_select => by_command( "${${process[${s}]}}" ),
         ifvarclass     => "${${class[${s}]}}",
         restart_class  => canonify( "efl_service_command_${${command[${s}]}}" );

   commands:
      "${${command[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment    => "Restart service is required.",
         handle     => "efl_service_commands_restart",
         classes    => efl_rkn( "${${command[${s}]}}", "efl_service_commands_restart" ),
         action     => efl_delta_reporting( "efl_service_commands_restart", "${${command[${s}]}}", "${${promisee[${s}]}}", "1" ),
         contain    => in_shell_and_silent,
         ifvarclass => or (
               canonify( "efl_service_command_${${command[${s}]}}" ),
               canonify( "${${config_file[${s}]}}_handle_efl_service_files_config_repaired" ),
               canonify( "${${config_file[${s}]}}_handle_efl_service_files_config_template_repaired" )
               );
}

body process_select by_command( command )
{
	command        => "${command}";
	process_result => "command";
}

bundle agent efl_chkconfig_enable_service ( ref )
{
   meta:
      "purpose" string => "Enable service boot using chkconfig.";
      "field_0" string => "Context";
      "field_1" string => "Service name promiser";
      "field_2" string => "Promisee";

   vars:
      debian::
         "chkconfig_check"
            comment => "Check mode required for Debian's chkconfig",
            string  => "${paths.path[chkconfig]} -c";

      !debian::
         "chkconfig_check"
            comment => "Check mode not required for none Debian",
            string  => "${paths.path[chkconfig]}";

      any::
         "dim_svc"
            comment => "Read data file for parsing.",
            handle  => "efl_chkconfig_enable_service_vars_files",
            int     => readstringarrayidx(
               "svc_o",
               "${ref}",
               "${efl_c.comment}",
               "${efl_c.array_delimiter}",
               "${efl_c.max_num}",
               "${efl_c.max_bytes}"
            );

         "s"
            comment => "Get index array loaded above.",
            handle  => "efl_chkconfig_enable_service_vars_s",
            slist   => getindices( "svc_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2" };

      "svc[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string => "${svc_o[${s}][${s2}]}";

      "class[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][0]";
      "service[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][1]";
      "promisee[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][2]";

   classes:
      _stdlib_path_exists_chkconfig::
         "efl_chkconfig_enable_${${service[${s}]}}"
            comment    => "Check if service is enabled",
            handle     => "efl_chkconfig_enable_classes_needs_repair",
            ifvarclass => "${${class[${s}]}}",
            not        => returnszero( "${chkconfig_check} ${${service[${s}]}}", "noshell" );

         "${${service[${s}]}}_handle_efl_chkconfig_enable_classes_ok_kept"
            comment    => "Check if service is enabled",
            handle     => "efl_chkconfig_enable_classes_ok",
            scope      => "namespace",
            ifvarclass => "${${class[${s}]}}",
            expression => returnszero( "${chkconfig_check} ${${service[${s}]}}", "noshell" );

   commands:
      "${paths.path[chkconfig]} ${${service[${s}]}} on" -> { "${${promisee[${s}]}}" }
         comment    => "Enable service using chkconfig",
         handle     => "efl_chkconfig_enable_service_commands_chkconfig",
         ifvarclass => canonify( "efl_chkconfig_enable_${${service[${s}]}}" ),
         classes    => efl_rkn( "${paths.path[chkconfig]} ${${service[${s}]}} off", "efl_chkconfig_enable_service_commands_chkconfig" ),
         action     => efl_delta_reporting( "efl_chkconfig_enable_service_commands_chkconfig", "${${service[${s}]}}", "${${promisee[${s}]}}", "1" ),
         contain    => silent;

   reports:
      delta_reporting::
         "${efl_c.udate} ;; efl_chkconfig_enable_classes_ok ;; ${${service[${s}]}} ;; ${${promisee[${s}]}}"
            ifvarclass      => canonify( "${${service[${s}]}}_handle_efl_chkconfig_enable_classes_ok_kept" ),
            report_to_file  => "${efl_c.promise_log}";

      !_stdlib_path_exists_chkconfig::
         "Promise ${this.handle} reports ${paths.path[chkconfig]} is not found."
            handle => "efl_chkconfig_enable_service_reports_no_chkconfig";

}

bundle agent efl_chkconfig_disable_service ( ref )
{
   meta:
      "purpose" string => "Disable service boot using chkconfig.";
      "field_0" string => "Context";
      "field_1" string => "Service name promiser";
      "field_2" string => "Promisee";

   vars:
      debian::
         "chkconfig_check"
            comment => "Check mode required for Debian's chkconfig",
            string  => "${paths.path[chkconfig]} -c";

      !debian::
         "chkconfig_check"
            comment => "Check mode not required for none Debian",
            string  => "${paths.path[chkconfig]}";

      any::
         "dim_svc"
            comment => "Read data file for parsing.",
            handle  => "efl_chkconfig_disable_service_vars_files",
            int     => readstringarrayidx(
               "svc_o",
               "${ref}",
               "${efl_c.comment}",
               "${efl_c.array_delimiter}",
               "${efl_c.max_num}",
               "${efl_c.max_bytes}"
            );

         "s"
            comment => "Get index array loaded above.",
            handle  => "efl_chkconfig_disable_service_vars_s",
            slist   => getindices( "svc_o" );

         "s2"
            comment => "Work around for bug 2333",
            slist => { "0", "1", "2" };

         "svc[${s}][${s2}]"
            comment => "Work around for bug 2333",
            string => "${svc_o[${s}][${s2}]}";

         "class[${s}]"
            comment => "Turn into reference for simpler reading.",
            string  => "svc[${s}][0]";
         "service[${s}]"
            comment => "Turn into reference for simpler reading.",
            string  => "svc[${s}][1]";
         "promisee[${s}]"
            comment => "Turn into reference for simpler reading.",
            string  => "svc[${s}][2]";

   classes:
      _stdlib_path_exists_chkconfig::
         "efl_chkconfig_disable_${${service[${s}]}}"
            comment    => "Check if service is enabled",
            handle     => "efl_chkconfig_disable_classes_needs_repair",
            ifvarclass => "${${class[${s}]}}",
            expression => returnszero( "${chkconfig_check} ${${service[${s}]}}", "noshell" );

         "${${service[${s}]}}_handle_efl_chkconfig_disable_classes_ok_kept"
            comment    => "Check if service is enabled",
            handle     => "efl_chkconfig_disable_classes_ok",
            scope      => "namespace",
            ifvarclass => "${${class[${s}]}}",
            not        => returnszero( "${chkconfig_check} ${${service[${s}]}}", "noshell" );

   commands:
      "${paths.path[chkconfig]} ${${service[${s}]}} off" -> { "${${promisee[${s}]}}" }
         comment    => "Enable service using chkconfig",
         handle     => "efl_chkconfig_disable_service_commands_chkconfig",
         ifvarclass => canonify( "efl_chkconfig_disable_${${service[${s}]}}" ),
         classes    => efl_rkn( "${paths.path[chkconfig]} ${${service[${s}]}} off", "efl_chkconfig_disable_service_commands_chkconfig" ),
         action     => efl_delta_reporting( "efl_chkconfig_disable_service_commands_chkconfig", "${${service[${s}]}}", "${${promisee[${s}]}}", "1" ),
         contain    => silent;

   reports:
      delta_reporting::
         "${efl_c.udate} ;; efl_chkconfig_disable_classes_ok ;; ${${service[${s}]}} ;; ${${promisee[${s}]}}"
            ifvarclass      => canonify( "${${service[${s}]}}_handle_efl_chkconfig_disable_classes_ok_kept" ),
            report_to_file  => "${efl_c.promise_log}";

      !_stdlib_path_exists_chkconfig::
         "Promise ${this.handle} reports ${paths.path[chkconfig]} is not found."
            handle => "efl_chkconfig_disable_service_reports_no_chkconfig";
}

bundle agent efl_file_perms ( ref )
{
   meta:
      "purpose" string => "Promise file permissions.";
      "field_0" string => "Context";
      "field_1" string => "Promiser file";
      "field_2" string => "Recurse into promiser directory no/#/inf)";
      "field_3" string => "Leaf regex";
      "field_4" string => "Negative match?";
      "field_5" string => "Promiser mode";
      "field_6" string => "Promiser owner";
      "field_7" string => "Promiser group";
      "field_8" string => "Promisee";

   vars:
      "dim_files"
         comment => "Read data file for parsing.",
         handle  => "efl_file_perms_vars_files",
         int     => readstringarrayidx(
            "files_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "f"
         comment => "Get index array loaded above.",
         handle  => "efl_file_perms_vars_f",
         slist   => getindices( "files_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6", "7", "8" };

      "files[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${files_o[${f}][${f2}]}";

      "class[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][0]";
      "file[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][1]";
      "recurse[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][2]";
      "leaf[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][3]";
      "negative[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][4]";
      "mode[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][5]";
      "user[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][6]";
      "group[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][7]";
      "promisee[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][8]";

      classes:
         "efl_no_recurse_${${file[${f}]}}"
            comment    => "Is recursion desired?",
            handle     => "efl_file_perms_classes_recurse",
            ifvarclass => "${${class[${f}]}}",
            expression => strcmp( "no", "${${recurse[${f}]}}" );
         
         "efl_negative_match_${${file[${f}]}}"
            comment => "Is negative match desired?",
            handle => "efl_file_perms_classes_negate",
            ifvarclass => "${${class[${f}]}}",
            expression => strcmp( "yes", "${${negative[${f}]}}" );

         "efl_positive_match_${${file[${f}]}}"
            comment => "Is positive match desired?",
            handle => "efl_file_perms_classes_positive",
            ifvarclass => "${${class[${f}]}}",
            expression => strcmp( "no", "${${negative[${f}]}}" );

      files:
         "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
            comment      => "Promise permissions of file recurse_with_base and positive match",
            handle       => "efl_file_perms_files_recurse_with_base_postive",
            ifvarclass   => and(
               not( canonify( "efl_no_recurse_${${file[${f}]}}" ) ),
               canonify( "efl_positive_match_${${file[${f}]}}")
               ),
            classes      => efl_rkn( "${${file[${f}]}}", "efl_file_perms_files_recurse_with_base_postive" ),
            action       => efl_delta_reporting( "efl_file_perms_files_recurse_with_base_postive", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
            depth_search => recurse_with_base( "${${recurse[${f}]}}" ),
            file_select  => by_name( "${${leaf[${f}]}}" ),
            perms        => mog( "${${mode[${f}]}}", "${${user[${f}]}}", "${${group[${f}]}}" );

         "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
            comment      => "Promise permissions of file recurse_with_base and negative leaf match",
            handle       => "efl_file_perms_files_recurse_with_base_negative",
            ifvarclass   => and(
               not( canonify( "efl_no_recurse_${${file[${f}]}}" ) ),
               canonify( "efl_negative_match_${${file[${f}]}}")
               ),
            classes      => efl_rkn( "${${file[${f}]}}", "efl_file_perms_files_recurse_with_base_negative" ),
            action       => efl_delta_reporting( "efl_file_perms_files_recurse_with_base_negative", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
            depth_search => recurse_with_base( "${${recurse[${f}]}}" ),
            file_select  => negate_by_name( "${${leaf[${f}]}}" ),
            perms        => mog( "${${mode[${f}]}}", "${${user[${f}]}}", "${${group[${f}]}}" );

         "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
            comment      => "Promise permissions using positive match",
            handle       => "efl_file_perms_files_positive",
            ifvarclass   => and(
               canonify( "efl_no_recurse_${${file[${f}]}}" ),
               canonify( "efl_positive_match_${${file[${f}]}}")
               ),
            classes      => efl_rkn( "${${file[${f}]}}", "efl_file_perms_files_positive" ),
            action       => efl_delta_reporting( "efl_file_perms_files_positive", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
            file_select  => by_name( "${${leaf[${f}]}}" ),
            perms        => mog( "${${mode[${f}]}}", "${${user[${f}]}}", "${${group[${f}]}}" );

         "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
            comment      => "Promise permissions using negative leaf match",
            handle       => "efl_file_perms_files_negative",
            ifvarclass   => and(
               canonify( "efl_no_recurse_${${file[${f}]}}" ),
               canonify( "efl_negative_match_${${file[${f}]}}")
               ),
            classes      => efl_rkn( "${${file[${f}]}}", "efl_file_perms_files_negative" ),
            action       => efl_delta_reporting( "efl_file_perms_files_negative", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
            file_select  => negate_by_name( "${${leaf[${f}]}}" ),
            perms        => mog( "${${mode[${f}]}}", "${${user[${f}]}}", "${${group[${f}]}}" );
}

body file_select negate_by_name(names)
{
   leaf_name  => { @(names)};
   file_result => "!leaf_name";
}

bundle agent efl_edit_template ( ref )
{
   meta:
      "purpose" string => "Promise whole contents of files";
      "field_0" string => "Class or context";
      "field_1" string => "Promiser file";
      "field_2" string => "Source file";
      "field_3" string => "Mode";
      "field_4" string => "User";
      "field_5" string => "Group";
      "field_6" string => "Promisee";

   vars:
      "dim_files"
         comment => "Read data file for parsing.",
         handle  => "efl_edit_template_vars_files",
         int     => readstringarrayidx(
            "files_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "f"
         comment => "Get index array loaded above.",
         handle  => "efl_edit_template_vars_f",
         slist   => getindices( "files_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6", "7", "8" };

      "files[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${files_o[${f}][${f2}]}";

      "class[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][0]";
      "file[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][1]";
      "source[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][2]";
      "mode[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][3]";
      "user[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][4]";
      "group[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][5]";
      "promisee[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][6]";

   files:
      "${efl_c.cache}/${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Locally cache template file.",
         handle     => "efl_edit_template_cache_template",
         classes    => efl_rkn( "${efl_c.cache}/${${file[${f}]}}", "efl_edit_template_cache_template" ),
         action     => efl_delta_reporting( "efl_edit_template_cache_template", "${efl_c.cache}/${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass => "${${class[${f}]}}",
         create     => "true",
         perms      => mog( "${${mode[${f}]}}", "${${user[${f}]}}", "${${group[${f}]}}" ),
         copy_from  => remote_dcp( "${${source[${f}]}}", "@{efl_c.policy_servers}" );

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment       => "Promise contents of file",
         handle        => "efl_edit_template_files_promiser",
         classes       => efl_rkn( "${${file[${f}]}}", "efl_edit_template_files_promiser" ),
         action        => efl_delta_reporting( "efl_edit_template_files_promiser", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass    => "${${class[${f}]}}",
         create        => "true",
         edit_defaults => empty,
         edit_template => "${efl_c.cache}/${${file[${f}]}}";

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Promise permissions of file",
         handle     => "efl_edit_template_files_perms",
         classes    => efl_rkn( "${${file[${f}]}}", "efl_edit_template_files_perms" ),
         action     => efl_delta_reporting( "efl_edit_template_files_perms", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass => "${${class[${f}]}}",
         perms      => mog( "${${mode[${f}]}}", "${${user[${f}]}}", "${${group[${f}]}}" );
}

bundle agent efl_lastseen
{
   meta:
      'purpose' string => "Report agents that have checked in, in the past 24 hours";

   vars:
      'hours'
         comment => "Last seen horizon in hours",
         int     => '24';

      'last_seen_hosts'
         comment => "Make list of addresses seen within the given hours",
         slist   => hostsseen( "${hours}", "lastseen", "address" );

   reports:
      cfengine::
         "${last_seen_hosts}"
            handle => "efl_lastseen_reports_hosts";
}

bundle agent efl_notseen
{
   meta:
      'purpose' string => "Report agents that have not checked in, in the past 24 hours";

   vars:
      'hours'
         comment => "Not seen within the last x hours",
         int     => '24';

      'last_seen_hosts'
         comment => "Make list of addresses not seen within the given hours",
         slist   => hostsseen( "${hours}", "notseen", "address" );

   reports:
      cfengine::
         "${last_seen_hosts}"
            handle => "efl_notseen_reports_hosts";
}

bundle agent efl_mon_cfengine
{
    meta:
        "purpose" string => "Report Cfengine connections stats from cf-monitord";

    reports:
        cfengine::
           "Current inbound connections: ${mon.value_cfengine_in}";
           "Average number of inbound connections per 5min: ${mon.av_cfengine_in}";
           "Standard deviation: ${mon.dev_cfengine_in}";
           "Current outbound connections: ${mon.value_cfengine_out}";
           "Average number of outbound connections per 5min: ${mon.av_cfengine_out}";
           "Standard deviation: ${mon.dev_cfengine_out}";
}

bundle server efl_server
{
# Not ready due to bug 5480.
   meta:
      "purpose" string => "Read cf-server access rules.";
      "input" string => "Takes a json file of documents in a list";
# [
#    {
#       "class" : "Context when when to apply access promise",
#       "path" :  "promiser path for access promiser",
#       "admit" : [ "ips", "or cdir", "to", "grant", "access too" ],
#       "admit_ips" : [ "ips", "to", "grant", "access too" ],
#       "admit_hostnames" : [ "hosts", "to", "grant", "access too" ],
#       "admit_keys" : [ "keys", "to", "grant", "access too" ],
#       "promisee" : "Promisee"
#    },
#    {
#       repeat new document for next access promise 
#    }
# ]
#
# Documents are processed in the order they appear. Order of elements in each
# document does not matter.

   vars:
      "d_raw"
         comment => "Read json file",
         data    => readjson( "${efl_c.efl_server_txt}", "512k" );
      "i"
         comment => "Index json data.",
         slist   => getindices( "d_raw" );

      "d[${i}][promisee]"
         comment => "Create new array to expand vars. See bug 2333",
         string  => "${d_raw[${i}][promisee]}";
      "d[${i}][path]"
         comment => "Create new array to expand vars. See bug 2333",
         string  => "${d_raw[${i}][path]}";
      "d[${i}][class]"
         comment => "Create new array to expand vars. See bug 2333",
         string  => "${d_raw[${i}][class]}";

      # create references for simple reading and editing
      "promisee[${i}]"  string => "d[${i}][promisee]";
      "path[${i}]"      string => "d[${i}][path]";
      "class[${i}]"     string => "d[${i}][class]";
      "admit"           slist  => getvalues( "d_raw[${i}][admit]" );
      "admit_ips"       slist  => getvalues( "d_raw[${i}][admit_ips]" );
      "admit_keys"      slist  => getvalues( "d_raw[${i}][admit_keys]" );
      "admit_hostnames" slist  => getvalues( "d_raw[${i}][admit_hostnames]" );

   access:
      "${${path[${i}]}}" -> { "${${promisee[${i}]}}" }
            handle          => "efl_server_new_grant_access_policy",
            comment         => "Grant client access to the policy server",
            ifvarclass      => "${${class[${i}]}}",
            admit           => { "@{admit}" },
            admit_ips       => { "@{admit_ips}" },
            admit_keys      => { "@{admit_keys}" },
            admit_hostnames => { "@{admit_hostnames}" };
}

body action efl_delta_reporting ( handle, promiser, promisee, if_elapsed )
{
   ifelapsed => "${if_elapsed}";

   upassive::
      action_policy => 'warn';

   delta_reporting::
      log_kept     => "${efl_c.promise_log}";
      log_repaired => "${efl_c.promise_log}";
      log_failed   => "${efl_c.promise_log}";
      log_string   => "${handle} ;; ${promiser} ;; ${promisee}";
# Remove date due to CFEngine bug 3441
      #log_string   => "${efl_c.udate} ;; ${handle} ;; ${promiser} ;; ${promisee}";
}

body classes efl_rkn( promiser, handle )
{
      promise_kept      => { "${promiser}_handle_${handle}_kept" };
      promise_repaired  => { "${promiser}_handle_${handle}_repaired" };
      repair_failed     => { "${promiser}_handle_${handle}_notkept" };
      repair_denied     => { "${promiser}_handle_${handle}_notkept" };
      repair_timeout    => { "${promiser}_handle_${handle}_notkept" };
}

bundle agent efl_bug3430 (ref)
{
   meta:
      "purpose" string => "Workaround CFEngine tcdb corruption and deadlock issues";
      "readme"  string => "See bug https://cfengine.com/dev/issues/3430";

   vars:
      redhat::
         "lsof" string => "/usr/sbin/lsof";

      debian::
         "lsof" string => "/usr/bin/lsof";

      any::
         "cf_lock_tcdb"
            comment => "Location of lock database",
            string  => "${sys.workdir}/state/cf_lock.tcdb";

         "cf_lock_tcdb_lock"
            comment => "Location of lock database",
            string  => "${cf_lock_tcdb}.lock";

         "lsof_pids_string"
            comment => "Count number of openings to cf_lock.tcdb",
            string  => execresult( "${lsof} -t ${cf_lock_tcdb_lock}", "noshell" );

         "lsof_pids"
            comment => "Convert string to list",
            slist   => splitstring( "${lsof_pids_string}", "\s+", "10" );

         "no_of_pids"
            comment => "Convert string returned from execresult to int",
            int     => length( "lsof_pids" );

   classes:
      "kill_pids"
         expression => isgreaterthan( "${no_of_pids}", "1" );

      "delete_cf_lock"
         expression => "cf_agent_handle_efl_bug3430_processes_kill_cf_agent_repaired";

      "report_kill_and_delete"
         expression => classmatch( ".*?_handle_efl_bug3430.*?_repaired" );

   files:
      delete_cf_lock::
         "${cf_lock_tcdb}" -> { "CFEngine bug 3430" }
            comment => "Remove corrupted lock file",
            handle  => "efl_bug3430_files_delete_cf_lock_tcdb",
            classes => efl_rkn( "${cf_lock_tcdb}", "efl_bug3430_files_delete_cf_lock_tcdb" ),
            action  => efl_delta_reporting( "efl_bug3430_files_delete_cf_lock_tcdb", "${cf_lock_tcdb}", "CFEngine bug 3430", "1" ),
            delete  => tidy;

   processes:
      kill_pids::
         "cf-agent" -> { "CFEngine bug 3430" }
            comment        => "Kill pids",
            handle         => "efl_bug3430_processes_kill_cf_agent",
            signals        => { "term", "kill" },
            classes        => efl_rkn( "cf-agent", "efl_bug3430_processes_kill_cf_agent" ),
            action         => efl_delta_reporting( "efl_bug3430_processes_kill_cf_agent", "cf-agent", "CFEngine bug 3430", "1" ),
            process_select => by_pid( "${lsof_pids}" );

   reports:
      report_kill_and_delete::
         "TCDB corruption detected. Repair was attempted.";
}

body process_select by_pid( pid )
{
   pid            => irange( "${pid}", "${pid}" );
   process_result => "pid";
}

bundle agent efl_rcs_pull( ref )
{
   meta:
      "purpose" string => "Build or update a copy from version control";
      "field_0" string => "Context";
      "field_1" string => "Update working copy command";
# Example: /usr/bin/git reset --hard HEAD && /usr/bin/git pull
      "field_2" string => "Checkout command to be used if update command fails";
# Example: /usr/bin/git clone https://github.com/evolvethinking/evolve_cfengine_freelib.git
      "field_3" string => "Destination directory, or your working directory";
      "field_4" string => "Mode for destination directory.";
      "field_5" string => "Owner";
      "field_6" string => "Group";
      "field_7" string => "Promisee";

   vars:
      "dim_rcs"
         comment => "Read data file for parsing.",
         handle  => "efl_rcs_pull_vars_files",
         int     => readstringarrayidx(
            "rcs_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "f"
         comment => "Get index array loaded above.",
         handle  => "efl_rcs_pull_vars_f",
         slist   => getindices( "rcs_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6", "7" };
 
      "rcs[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${rcs_o[${f}][${f2}]}";

      "class[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][0]";
      "update[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][1]";
      "checkout[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][2]";
      "dir[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][3]";
      "mode[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][4]";
      "owner[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][5]";
      "group[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][6]";
      "promisee[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][7]";

   files:
      "${${dir[${f}]}}/." -> { "${${promisee[${f}]}}" }
         comment    => "Create destination directory",
         handle     => "efl_rcs_pull_files_create_dir",
         ifvarclass => "${${class[${f}]}}",
         classes    => efl_rkn( "${${dir[${f}]}}", "efl_rcs_pull_files_create_dir" ),
         action     => efl_delta_reporting( "efl_rcs_pull_files_create_dir", "${${dir[${f}]}}", "${${promisee[${f}]}}", "1" ),
         create     => 'true';

      "${${dir[${f}]}}/." -> { "${${promisee[${f}]}}" }
         comment    => "promise perms on destination directory",
         handle     => "efl_rcs_pull_files_dir_perms",
         ifvarclass => "${${class[${f}]}}",
         classes    => efl_rkn( "${${dir[${f}]}}", "efl_rcs_pull_files_dir_perms" ),
         action     => efl_delta_reporting( "efl_rcs_pull_files_dir_perms", "${${dir[${f}]}}", "${${promisee[${f}]}}", "1" ),
         perms      => mog( "${${mode[${f}]}}", "${${owner[${f}]}}", "${${group[${f}]}}" );

      "${${dir[${f}]}}/." -> { "${${promisee[${f}]}}" }
         comment      => "purge destination directory if update command failed",
         handle       => "efl_rcs_files_purge_dir",
         ifvarclass   => canonify( "${${update[${f}]}}_handle_efl_rcs_pull_commands_update_notkept" ),
         delete       => tidy,
         depth_search => recurse( "inf" ),
         file_select  => by_name( ".*" ),
         classes      => efl_rkn( "${${dir[${f}]}}", "efl_rcs_files_purge_dir" ),
         action       => efl_delta_reporting( "efl_rcs_files_purge_dir", "${${dir[${f}]}}", "${${promisee[${f}]}}", "1" );

   commands:
      "${${update[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Pull update",
         handle     => "efl_rcs_pull_commands_update",
         ifvarclass => "${${class[${f}]}}",
         contain    => in_dir_shell_and_silent( "${${dir[${f}]}}" ),
         classes    => efl_rkn( "${${update[${f}]}}", "efl_rcs_pull_commands_update" ),
         action     => efl_delta_reporting( "efl_rcs_pull_commands_update", "${${update[${f}]}}", "${${promisee[${f}]}}", "1" );

      "${${checkout[${f}]}} ${${dir[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Pull checkout",
         handle     => "efl_rcs_pull_commands_checkout",
         depends_on => { "efl_rcs_files_purge_dir" },
         ifvarclass => "${${class[${f}]}}",
         contain    => in_dir_shell_and_silent( "${${dir[${f}]}}" ),
         classes    => efl_rkn( "${${checkout[${f}]}}", "efl_rcs_pull_commands_checkout" ),
         action     => efl_delta_reporting( "efl_rcs_pull_commands_checkout", "${${checkout[${f}]}}", "${${promisee[${f}]}}", "1" );
}
