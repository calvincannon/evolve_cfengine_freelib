bundle common efl_c
{
   meta:
      "purpose" string => "Common configs for all EFL bundles";

   vars:
#
# Configs for reading data files
#
      "cache"
         comment => "Location for agent to cache template and other temp files",
         string  => "/var/cache/cfengine";

      "class"
         comment => "Regex to extract class name from parameter file name.",
         string  => ".*?-(\w+)\.txt";

      "comment"
         comment => "Comment string in data file.",
         string  => "\s*#[^\n]*";

      "array_delimiter"
         comment => "Field delimiter for CSV data files read by readstringarrayidx",
         string  => "\s*;;\s*";

      "slist_delimiter"
         comment => "Field delimiter for CSV data files read by readstringlist",
         string  => "\s";

      "max_num"
         comment => "Maximum number of lines to read from data file",
         int     => "500";

      "max_bytes"
         comment => "Maximum number of bytes to read from data file.",
         string  => "1M";

      "json_file"
         comment => "How to determine if param file is json",
         string  => ".*\.(json|dat|jsn)";

      "csv_file"
         comment => "How to determine if param file is csv",
         string  => ".*\.(txt|csv)";
#
# Delta Reporting configs
#
      "logdir"
         comment => "Log dir for Delta Reporting logs",
         string => "${sys.workdir}/delta_reporting/log";

      "promise_log"
         comment => "Location for experimental promise outcome log.",
         string  => "${logdir}/promises";

      "udate"
         comment => "Date stamp to match agent output",
         string  => strftime( "localtime", "%Y-%m-%dT%H:%M:%S%z", now() );

#
# Misc vars
#
      "efl_server_txt"
            comment => "Server access rules parameter file",
# NOTE Access file must be hardcoded because server bundles do not accept arguments.
            string => "${sys.workdir}/inputs/efl_data/bundle_params/efl_server.txt";

   reports:
      debug::
         "policy_servers => ${policy_servers}"
            comment => "Set debug to see debugging reports";
}

bundle agent efl_main( ref )
{
   meta:
      "meta_purpose" string => "All policies are called via methods iteration from this bundle.";

      "method_field_0" string => "Context when method is called";
      "method_field_1" string => "Method promiser name";
      "method_field_2" string => "Bundle name";
      "method_field_3" string => "Ifelapsed";
      "method_field_4" string => "Bundle parameter";
      "method_field_5" string => "Promisee";

   vars:
      "dim_methods"
         comment => "Read data to be used in method promises.",
         int     => readstringarrayidx(
            "meth_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
            );

      "i_unsorted" 
         comment => "index from csv file may not be the correct order",
         slist   => getindices( "meth_o" );

      "i"
         slist => sort( "i_unsorted", "int" );

      "i2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5" };
 
      "meth[${i}][${i2}]"
         comment => "Work around for bug 2333",
         string => "${meth_o[${i}][${i2}]}";

      "class[${i}]"
         comment => "Turn into reference for simpler reading.",
         string  => "meth[${i}][0]";
      "promiser[${i}]"
         comment => "Turn into reference for simpler reading.",
         string  => "meth[${i}][1]";
      "bundle[${i}]"
         comment => "Turn into reference for simpler reading.",
         string  => "meth[${i}][2]";
      "ifelapsed[${i}]"
         comment => "Turn into reference for simpler reading.",
         string  => "meth[${i}][3]";
      "parameter[${i}]"
         comment => "Turn into reference for simpler reading.",
         string  => "meth[${i}][4]";
      "promisee[${i}]"
         comment => "Turn into reference for simpler reading.",
         string  => "meth[${i}][5]";

   classes:
## If you call this bundle outside of efl_main, these classes will test for
## a json or csv parameter file. Warning, using this way you lose a pass.
      "parse_${param_file}_as_json"
         comment    => "Is parameter file json?",
         expression => regcmp( ${efl_c.json_file}, ${ref} );

      "parse_${param_file}_as_csv"
         comment    => "Is parameter file csv?",
         expression => regcmp( ${efl_c.csv_file}, ${ref} );

   methods:
      "methods loop wrapper"
         comment    => "Call wrapper bundle to workaround naked variable bug.",
         handle     => "efl_main_methods_efl_bug2638",
         ifvarclass => "${${class[${i}]}}",
         action     => efl_if_elapsed( "${${ifelapsed[${i}]}}" ),
         usebundle  => efl_bug2638(
            "${${promiser[${i}]}}_${i}",
            "${${promisee[${i}]}}",
            "${${bundle[${i}]}}",
            "${${parameter[${i}]}}"
         );
}

bundle agent efl_bug2638(promiser_name, promisee_name, bundle_name, parameter)
{
   meta:
      "meta_purpose" string => "Workaround for naked variable bug 2638.";
      "bug"          string => "https://cfengine.com/dev/issues/2638";

   methods:
      "${promiser_name}" -> { "${promisee_name}" }
         comment    => "Methods promises described in methods.txt",
         handle     => "efl_bug2638_methods_loop",
         usebundle  => ${bundle_name}( "${parameter}" );
}

bundle agent efl_class_returnszero( ref )
{
   meta:
      "purpose" string => "Skeleton bundle for new bundle authoring";
      "field_0" string => "Context";
      "field_1" string => "Class to set";
      "field_2" string => "Command to run";
      "field_3" string => "useshell/noshell";
      "field_4" string => "Set class if returns zero (yes) or non-zero (no)";
      "field_5" string => "Promisee";

   vars:
      "dim_rz"
         comment => "Read data file for parsing.",
         handle  => "efl_class_returnszero_vars_files",
         int     => readstringarrayidx(
            "rz_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "f"
         comment => "Get index array loaded above.",
         handle  => "efl_class_returnszero_vars_f",
         slist   => getindices( "rz_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6" };
 
      "rz[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${rz_o[${f}][${f2}]}";

      "class[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rz[${f}][0]";
      "class_to_set[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rz[${f}][1]";
      "command[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rz[${f}][2]";
      "shell[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rz[${f}][3]";
      "negate[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rz[${f}][4]";
      "promisee[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rz[${f}][5]";

   classes:
      "${${class_to_set[${f}]}}_non_zero" -> { "${${promisee[${f}]}}" }
         comment    => "Does class to set result from zero or non zero return value",
         ifvarclass => "${${class[${f}]}}",
         expression => strcmp( "${${negate[${f}]}}", "no" );

      "${${class_to_set[${f}]}}_zero" -> { "${${promisee[${f}]}}" }
         comment    => "Does class to set result from zero or non zero return value",
         ifvarclass => "${${class[${f}]}}",
         expression => strcmp( "${${negate[${f}]}}", "yes" );

      "${${class_to_set[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Set class if expression returns non zero",
         ifvarclass => "${${class_to_set[${f}]}}_non_zero",
         scope      => "namespace",
         not        => returnszero( "${${command[${f}]}}", "${${shell[${f}]}}" );

      "${${class_to_set[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Set class if expression returns zero",
         ifvarclass => "${${class_to_set[${f}]}}_zero",
         scope      => "namespace",
         expression => returnszero( "${${command[${f}]}}", "${${shell[${f}]}}" );
}

bundle agent efl_global_slists( ref )
{
   meta:
      "purpose" string => "Set slist type variable when class is true.";
      "field_0" string => "Context";
      "field_1" string => "Variable name";
      "field_2" string => "csv inline list or path to external file where file format is one list element per line.";
		"field_4" string => "random shuffle list (r), or determistic shuffle (d), or normal (n)";
      "field_3" string => "Promisee";

   vars:
      "dim_slist"
         comment => "Read data file for parsing.",
         handle  => "efl_global_slists_vars_files",
         int     => readstringarrayidx(
            "slist_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "s"
         comment => "Get index array loaded above.",
         handle  => "efl_global_slists_vars_s",
         slist   => getindices( "slist_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4" };

      "slist[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string  => "${slist_o[${s}][${s2}]}";

      "class[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "slist[${s}][0]";
      "name[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "slist[${s}][1]";
      "list_data[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "slist[${s}][2]";
      "shuffle[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "slist[${s}][3]";
      "promisee[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "slist[${s}][4]";

		"seed" int => randomint( "1", "999999" );

		"pre_shuffle_${${name[${s}]}}"
			comment => "Get list from external file",
			ifvarclass => and( "parse_list_file_${s}", "${${class[${s}]}}"),
			slist => readstringlist(
				"${${list_data[${s}]}}",
				"\s*#[^\n]*",
				"\n",
				"500",
				"1M"
				);

		"pre_shuffle_${${name[${s}]}}"
			comment    => "Get list from external file",
			ifvarclass => and( "parse_csv_list_${s}" , "${${class[${s}]}}"),
         policy     => "free",
			slist      => splitstring( "${${list_data[${s}]}}", "\s*,\s*", "500" );

		"${${name[${s}]}}"
			comment    => "no shuffle list",
			ifvarclass => "n_shuffle_${s}",
         policy     => "free",
			slist      => { "@{pre_shuffle_${${name[${s}]}}}" };

		"${${name[${s}]}}"
			comment    => "random shuffle list",
			ifvarclass => "r_shuffle_${s}",
         policy     => "free",
			slist      => shuffle( "pre_shuffle_${${name[${s}]}}", "${seed}" );

		"${${name[${s}]}}"
			comment    => "deterministic shuffle list",
			ifvarclass => "d_shuffle_${s}",
         policy     => "free",
			slist      => shuffle( "pre_shuffle_${${name[${s}]}}", "${sys.uqhost}" );

	classes:
		"parse_list_file_${s}"
			comment    => "Determine if list_data points to a file",
			ifvarclass => "${${class[${s}]}}",
			expression => fileexists( "${${list_data[${s}]}}" );

		"parse_csv_list_${s}"
			comment    => "If no file then assume data is inline csv",
			ifvarclass => "${${class[${s}]}}",
			not        => fileexists( "${${list_data[${s}]}}" );

	  "d_shuffle_${s}"
			comment    => "Determnistically random list.",
			ifvarclass => "${${class[${s}]}}",
			expression => strcmp( "${${shuffle[${s}]}}", "d" );

	  "r_shuffle_${s}"
			comment    => "Random list.",
			ifvarclass => "${${class[${s}]}}",
			expression => strcmp( "${${shuffle[${s}]}}", "r" );

	  "n_shuffle_${s}"
			comment    => "Normal list without random.",
			ifvarclass => "${${class[${s}]}}",
			expression => strcmp( "${${shuffle[${s}]}}", "n" );

}

bundle agent efl_global_strings ( ref )
{
   meta:
      "purpose" string => "Set string type variable when class is true.";
      "field_0" string => "Context";
      "field_1" string => "Variable name";
      "field_2" string => "Variable value";
      "field_3" string => "Promisee";

   vars:
      "dim_string"
         comment => "Read data file for parsing.",
         handle  => "efl_global_strings_vars_files",
         int     => readstringarrayidx(
            "string_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "s"
         comment => "Get index array loaded above.",
         handle  => "efl_global_strings_vars_s",
         slist   => getindices( "string_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3" };

      "string[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string => "${string_o[${s}][${s2}]}";

      "class[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "string[${s}][0]";
      "name[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "string[${s}][1]";
      "value[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "string[${s}][2]";
      "promisee[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "string[${s}][3]";

      "${${name[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment    => "Define variable if class is true",
         policy     => "free",
         ifvarclass => "${${class[${s}]}}",
         string     => "${${value[${s}]}}";
}

bundle agent efl_class_cmd_regcmp( ref )
{
   meta:
      "purpose" string => "Set global class if the given command output matches regex.";
      "wanring" string => "Commands in classes and variables are expensive";
      "field_0" string => "Context";
      "field_1" string => "Class promiser to set";
      "field_2" string => "Use 'expression' or 'not' in class promise";
      "field_3" string => "command to run";
      "field_4" string => "useshell or noshell";
      "field_5" string => "anchored regex to match command output";
      "field_6" string => "Promisee";

   vars:
      "dim_class"
         comment => "Read data file for parsing.",
         handle  => "efl_class_cmd_regcmp_vars_files",
         int     => readstringarrayidx(
            "class_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "c"
         comment => "Get index array loaded above.",
         handle  => "efl_class_cmd_regcmp_vars_c",
         slist   => getindices( "class_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6" };

      "class[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${class_o[${c}][${c2}]}";

      "context[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][0]";
      "class_to_set[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][1]";
      "exp_or_not[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][2]";
      "command[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][3]";
      "useshell[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][4]";
      "regex[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][5]";
      "promisee[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][6]";

      "cmd_output_${c}" -> { "${${promisee[${c}]}}" }
         comment    => "Capture commmand output",
         ifvarclass => "${${context[${c}]}}",
         string     => execresult( "${${command[${c}]}}", "${${useshell[${c}]}}" );

   classes:
      "use_not_for_${c}" -> { "${${promisee[${c}]}}" }
         comment    => "Use not rather than expression",
         ifvarclass => "${${context[${c}]}}",
         expression => strcmp( "${${exp_or_not[${c}]}}", "yes" );

      "use_expression_for_${c}" -> { "${${promisee[${c}]}}" }
         comment    => "Use expression",
         ifvarclass => "${${context[${c}]}}",
         expression => strcmp( "${${exp_or_not[${c}]}}", "no" );

      "${${class_to_set[${c}]}}" -> { "${${promisee[${c}]}}" }
         comment    => "Set class if command output matches the anchored regex.",
         scope      => "namespace",
         ifvarclass => "use_expression_for_${c}",
         expression => regcmp( "${${regex[${c}]}}", "${cmd_output_${c}}" );

      "${${class_to_set[${c}]}}" -> { "${${promisee[${c}]}}" }
         comment    => "Set class if command output does not match the anchored regex.",
         scope      => "namespace",
         ifvarclass => "use_not_for_${c}",
         not        => regcmp( "${${regex[${c}]}}", "${cmd_output_${c}}" );
}

bundle agent efl_class_expression( ref )
{
   meta:
      "purpose" string => "Set global class if the given class expression is true.";
      "field_0" string => "Class promiser";
      "field_1" string => "Class expression";
      "field_2" string => "Promisee";

   vars:
      "dim_class"
         comment => "Read data file for parsing.",
         handle  => "efl_class_expression_vars_files",
         int     => readstringarrayidx(
            "class_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "c"
         comment => "Get index array loaded above.",
         handle  => "efl_class_expression_vars_c",
         slist   => getindices( "class_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2" };

      "class[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${class_o[${c}][${c2}]}";

      "class_to_set[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][0]";
      "class_expression[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][1]";
      "promisee[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][2]";

   classes:
      "${${class_to_set[${c}]}}" -> { "${${promisee[${c}]}}" }
         comment    => "Set class if expression is true.",
         scope      => "namespace",
         expression => "${${class_expression[${c}]}}";
}

bundle agent efl_class_classmatch( ref )
{
   meta:
      "purpose" string => "Set global class if the given regex matches a defined class";
      "field_0" string => "Class promiser";
      "field_1" string => "Regex for the function classmatch";
      "field_2" string => "Promisee";

   vars:
      "dim_class"
         comment => "Read data file for parsing.",
         handle  => "efl_class_classmatch_vars_files",
         int     => readstringarrayidx(
            "class_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "c"
         comment => "Get index array loaded above.",
         handle  => "efl_class_classmatch_vars_c",
         slist   => getindices( "class_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2" };

      "class[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${class_o[${c}][${c2}]}";

      "class_to_set[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][0]";
      "regex[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][1]";
      "promisee[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][2]";

   classes:
      "${${class_to_set[${c}]}}" -> { "${${promisee[${c}]}}" }
         comment    => "Set class if classmatch function returns true.",
         scope      => "namespace",
         expression => classmatch( "${${regex[${c}]}}" );
}

bundle agent efl_class_iprange( ref )
{
   meta:
      "purpose" string => "Set global class if host IP is within the given range";
      "field_0" string => "Class promiser";
      "field_1" string => "IP address range in the format of the iprange function.";
      "field_2" string => "Promisee";

   vars:
      "dim_class"
         comment => "Read data file for parsing.",
         handle  => "efl_class_iprange_vars_files",
         int     => readstringarrayidx(
            "class_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "c"
         comment => "Get index array loaded above.",
         handle  => "efl_class_iprange_vars_c",
         slist   => getindices( "class_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2" };

      "class[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${class_o[${c}][${c2}]}";

      "class_to_set[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][0]";
      "ip_range[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][1]";
      "promisee[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][2]";

   classes:
      "${${class_to_set[${c}]}}" -> { "${${promisee[${c}]}}" }
         comment    => "Set class if iprange function returns true.",
         scope      => "namespace",
         expression => iprange( "${${ip_range[${c}]}}" );
}

bundle agent efl_class_hostname( ref )
#
# Reads parameter file in the form of <name>-<class>.txt.
# the file contains a list of unqualified hostnames separated by white space.
# If ${sys.uqhost} matches any name in the list <class> is defined.
{
   meta:
      "purpose" string => "Set global class if list item matches hostname";
      "field_0" string => "unqualified hostname";

   classes:
      "check_hostnames_${ref}"
         comment    => "Get class name from filename",
         expression => regextract( "${efl_c.class}", "${ref}", "class" );
      
      "${class[1]}"
         comment    => "Set class if unqualified hostname matches any list element.",
         scope      => "namespace",
         ifvarclass => canonify( "check_hostnames_${ref}" ),
         expression => regline( "${sys.uqhost}", "${ref}" );
}

body action efl_if_elapsed(x)
{
ifelapsed => "$(x)";
expireafter => "$(x)";
}
