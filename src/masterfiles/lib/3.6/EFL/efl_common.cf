bundle common efl_c
{
   meta:
      "purpose" string => "Common configs for all EFL bundles";

   vars:
#
# Configs for reading data files
#
      "cache"
         comment => "Location for agent to cache template and other temp files",
         string  => "/var/cache/cfengine";

      "class"
         comment => "Regex to extract class name from parameter file name.",
         string  => ".*?-(\w+)\.txt";

      "comment"
         comment => "Comment string in data file.",
         string  => "\s*#[^\n]*";

      "array_delimiter"
         comment => "Field delimiter for CSV data files read by readstringarrayidx",
         string  => "\s*;;\s*";

      "slist_delimiter"
         comment => "Field delimiter for CSV data files read by readstringlist",
         string  => "\s";

      "max_num"
         comment => "Maximum number of lines to read from data file",
         int     => "500";

      "max_bytes"
         comment => "Maximum number of bytes to read from data file.",
         string  => "1M";

      "json_file"
         comment => "How to determine if param file is json",
         string  => ".*\.(json|dat|jsn)";

      "csv_file"
         comment => "How to determine if param file is csv",
         string  => ".*\.(txt|csv)";
#
# Delta Reporting configs
#
      "logdir"
         comment => "Log dir for Delta Reporting logs",
         string => "${sys.workdir}/delta_reporting/log";

      "promise_log"
         comment => "Location for experimental promise outcome log.",
         string  => "${logdir}/promises";

      "udate"
         comment => "Date stamp to match agent output",
         string  => strftime( "localtime", "%Y-%m-%dT%H:%M:%S%z", now() );

#
# Misc vars
#
      "efl_server_txt"
            comment => "Server access rules parameter file",
# NOTE Access file must be hardcoded because server bundles do not accept arguments.
            string => "${sys.workdir}/inputs/efl_data/bundle_params/efl_server.txt";

   reports:
      debug::
         "policy_servers => ${policy_servers}"
            comment => "Set debug to see debugging reports";
}

bundle agent efl_main( ref )
{
   meta:
      "meta_purpose" string => "All policies are called via methods iteration from this bundle.";

      "method_field_0" string => "Context when method is called";
      "method_field_1" string => "Method promiser name";
      "method_field_2" string => "Bundle name";
      "method_field_3" string => "Ifelapsed";
      "method_field_4" string => "Bundle parameter";
      "method_field_5" string => "Promisee";

   vars:
      "params"   
         comment    => "Parameter field names and positions to be parsed.",
         data       => parsejson(
         '{
            "0" : "class",
            "1" : "promiser",
            "2" : "bundle",
            "3" : "ifelapsed",
            "4" : "parameter",
            "5" : "promisee"
         }');

   <efl param_parser efl/>

   classes:
   <efl param_file_picker efl/>

   methods:
      "methods loop wrapper"
         comment    => "Call wrapper bundle to workaround naked variable bug.",
         handle     => "efl_main_methods_efl_bug2638",
         ifvarclass => "${d[${i}][class]}",
         action     => efl_if_elapsed( "${d[${i}][ifelapsed]}" ),
         usebundle  => efl_bug2638(
            "${d[${i}][promiser]}_${i}",
            "${d[${i}][promisee]}",
            "${d[${i}][bundle]}",
            "${d[${i}][parameter]}"
         );
}

bundle agent efl_bug2638(promiser_name, promisee_name, bundle_name, parameter)
{
   meta:
      "meta_purpose" string => "Workaround for naked variable bug 2638.";
      "bug"          string => "https://cfengine.com/dev/issues/2638";

   vars:
      "param_file" string => canonifyuniquely( "${parameter}" );

   classes:
## These classes are used by the bundle called in the methods. Declaring the
## class at this level saves a pass in the called bundle
      "parse_${param_file}_as_json"
         comment    => "Is parameter file json?",
         scope      => 'namespace',
         expression => regcmp( ${efl_c.json_file}, ${parameter} );

      "parse_${param_file}_as_csv"
         comment    => "Is parameter file csv?",
         scope      => 'namespace',
         expression => regcmp( ${efl_c.csv_file}, ${parameter} );

   methods:
      "${promiser_name}" -> { "${promisee_name}" }
         comment    => "Methods promises described in methods.txt",
         handle     => "efl_bug2638_methods_loop",
         usebundle  => ${bundle_name}( "${parameter}" );
}

bundle agent efl_class_returnszero( ref )
{
   meta:
      "purpose" string => "Skeleton bundle for new bundle authoring";
      "field_0" string => "Context";
      "field_1" string => "Class to set";
      "field_2" string => "Command to run";
      "field_3" string => "useshell/noshell";
      "field_4" string => "Set class if returns zero (yes) or non-zero (no)";
      "field_5" string => "Promisee";

   vars:
      "params"   
         comment    => "Parameter field names and positions to be parsed.",
         data       => parsejson(
         '{
            "0" : "class",
            "1" : "class_to_set",
            "2" : "command",
            "3" : "shell",
            "4" : "zero",
            "5" : "promisee"
         }');

      <efl param_parser efl/>

   classes:
      <efl param_file_picker efl/>

      "${d[${i}][class_to_set]}_non_zero" -> { "${d[${i}][promisee]}" }
         comment    => "Does class to set result from zero or non zero return value",
         ifvarclass => "${d[${i}][class]}",
         expression => strcmp( "${d[${i}][zero]}", "no" );

      "${d[${i}][class_to_set]}_zero" -> { "${d[${i}][promisee]}" }
         comment    => "Does class to set result from zero or non zero return value",
         ifvarclass => "${d[${i}][class]}",
         expression => strcmp( "${d[${i}][zero]}", "yes" );

      "${d[${i}][class_to_set]}" -> { "${d[${i}][promisee]}" }
         comment    => "Set class if expression returns non zero",
         ifvarclass => "${d[${i}][class_to_set]}_non_zero",
         scope      => "namespace",
         not        => returnszero( "${d[${i}][command]}", "${d[${i}][shell]}" );

      "${d[${i}][class_to_set]}" -> { "${d[${i}][promisee]}" }
         comment    => "Set class if expression returns zero",
         ifvarclass => "${d[${i}][class_to_set]}_zero",
         scope      => "namespace",
         expression => returnszero( "${d[${i}][command]}", "${d[${i}][shell]}" );
}

bundle agent efl_global_slists( ref )
{
   meta:
      "purpose" string => "Set slist type variable when class is true.";
      "field_0" string => "Context";
      "field_1" string => "Variable name";
      "field_2" string => "csv inline list or path to external file where file format is one list element per line.";
		"field_4" string => "random shuffle list (r), or determistic shuffle (d), or normal (n)";
      "field_3" string => "Promisee";

   vars:
      "params"
         comment => "Parameter field names and positions to be parsed.",
         data    => parsejson(
         '{
            "0" : "class",
            "1" : "name",
            "2" : "contents",
            "3" : "shuffle",
            "4" : "promisee"
         }');

   <efl param_parser efl/>

## processing data
      "pre_shuffle_${d[${i}][name]}"
         comment    => "Get slist from csv list inside data container",
         ifvarclass => "split_csv_list_${d[${i}][name]}",
         slist      => splitstring( "${d[${i}][contents]}", "\s*,\s*", "500" );

      "pre_shuffle_${d[${i}][name]}"
         comment    => "Get slist from file referenced inside data contaier",
         ifvarclass => "read_list_from_file_${d[${i}][name]}",
         slist      => readstringlist( 
            "${d[${i}][contents]}",
            "${efl_c.comment}",
            "\s*\n\s*",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "${d[${i}][name]}"
         ifvarclass => "no_shuffle_${d[${i}][name]}",
         slist      => { "@{pre_shuffle_${d[${i}][name]}}" };

		"seed" int => randomint( "1", "999999" );

      "${d[${i}][name]}"
         ifvarclass => "random_shuffle_${d[${i}][name]}",
         slist      => shuffle( "pre_shuffle_${d[${i}][name]}", ${seed} );

      "${d[${i}][name]}"
         ifvarclass => "deterministic_shuffle_${d[${i}][name]}",
         slist      => shuffle( "pre_shuffle_${d[${i}][name]}", ${sys.uqhost} );

	classes:
      <efl param_file_picker efl/>

      "no_shuffle_${d[${i}][name]}"
         ifvarclass => "${d[${i}][class]}",
         expression => strcmp( "${d[${i}][shuffle]}", "n" );

      "random_shuffle_${d[${i}][name]}"
         ifvarclass => "${d[${i}][class]}",
         expression => strcmp( "${d[${i}][shuffle]}", "r" );

      "deterministic_shuffle_${d[${i}][name]}"
         ifvarclass => "${d[${i}][class]}",
         expression => strcmp( "${d[${i}][shuffle]}", "d" );

      "read_list_from_file_${d[${i}][name]}"
         ifvarclass => "${d[${i}][class]}",
         expression => fileexists( "${d[${i}][contents]}" );

      "split_csv_list_${d[${i}][name]}"
         ifvarclass => "${d[${i}][class]}",
         expression => regcmp( "[^,]+,.*", "${d[${i}][contents]}" );
}

bundle agent efl_global_strings ( ref )
{
   meta:
      "purpose" string => "Set string type variable when class is true.";
      "field_0" string => "Context";
      "field_1" string => "Variable name";
      "field_2" string => "Variable value";
      "field_3" string => "Promisee";

   vars:
      "dim_string"
         comment => "Read data file for parsing.",
         handle  => "efl_global_strings_vars_files",
         int     => readstringarrayidx(
            "string_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "s"
         comment => "Get index array loaded above.",
         handle  => "efl_global_strings_vars_s",
         slist   => getindices( "string_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3" };

      "string[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string => "${string_o[${s}][${s2}]}";

      "class[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "string[${s}][0]";
      "name[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "string[${s}][1]";
      "value[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "string[${s}][2]";
      "promisee[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "string[${s}][3]";

      "${${name[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment    => "Define variable if class is true",
         policy     => "free",
         ifvarclass => "${${class[${s}]}}",
         string     => "${${value[${s}]}}";
}

bundle agent efl_class_cmd_regcmp( ref )
{
   meta:
      "purpose" string => "Set global class if the given command output matches regex.";
      "wanring" string => "Commands in classes and variables are expensive";
      "field_0" string => "Context";
      "field_1" string => "Class promiser to set";
      "field_2" string => "Use 'expression' or 'not' in class promise";
      "field_3" string => "command to run";
      "field_4" string => "useshell or noshell";
      "field_5" string => "anchored regex to match command output";
      "field_6" string => "Promisee";

   vars:
      "dim_class"
         comment => "Read data file for parsing.",
         handle  => "efl_class_cmd_regcmp_vars_files",
         int     => readstringarrayidx(
            "class_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "c"
         comment => "Get index array loaded above.",
         handle  => "efl_class_cmd_regcmp_vars_c",
         slist   => getindices( "class_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6" };

      "class[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${class_o[${c}][${c2}]}";

      "context[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][0]";
      "class_to_set[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][1]";
      "exp_or_not[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][2]";
      "command[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][3]";
      "useshell[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][4]";
      "regex[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][5]";
      "promisee[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][6]";

      "cmd_output_${c}" -> { "${${promisee[${c}]}}" }
         comment    => "Capture commmand output",
         ifvarclass => "${${context[${c}]}}",
         string     => execresult( "${${command[${c}]}}", "${${useshell[${c}]}}" );

   classes:
      "use_not_for_${c}" -> { "${${promisee[${c}]}}" }
         comment    => "Use not rather than expression",
         ifvarclass => "${${context[${c}]}}",
         expression => strcmp( "${${exp_or_not[${c}]}}", "yes" );

      "use_expression_for_${c}" -> { "${${promisee[${c}]}}" }
         comment    => "Use expression",
         ifvarclass => "${${context[${c}]}}",
         expression => strcmp( "${${exp_or_not[${c}]}}", "no" );

      "${${class_to_set[${c}]}}" -> { "${${promisee[${c}]}}" }
         comment    => "Set class if command output matches the anchored regex.",
         scope      => "namespace",
         ifvarclass => "use_expression_for_${c}",
         expression => regcmp( "${${regex[${c}]}}", "${cmd_output_${c}}" );

      "${${class_to_set[${c}]}}" -> { "${${promisee[${c}]}}" }
         comment    => "Set class if command output does not match the anchored regex.",
         scope      => "namespace",
         ifvarclass => "use_not_for_${c}",
         not        => regcmp( "${${regex[${c}]}}", "${cmd_output_${c}}" );
}

bundle agent efl_class_expression( ref )
{
   meta:
      "purpose" string => "Set global class if the given class expression is true.";
      "field_0" string => "Class promiser";
      "field_1" string => "Class expression";
      "field_2" string => "Promisee";

   vars:
      "dim_class"
         comment => "Read data file for parsing.",
         handle  => "efl_class_expression_vars_files",
         int     => readstringarrayidx(
            "class_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "c"
         comment => "Get index array loaded above.",
         handle  => "efl_class_expression_vars_c",
         slist   => getindices( "class_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2" };

      "class[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${class_o[${c}][${c2}]}";

      "class_to_set[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][0]";
      "class_expression[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][1]";
      "promisee[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][2]";

   classes:
      "${${class_to_set[${c}]}}" -> { "${${promisee[${c}]}}" }
         comment    => "Set class if expression is true.",
         scope      => "namespace",
         expression => "${${class_expression[${c}]}}";
}

bundle agent efl_class_classmatch( ref )
{
   meta:
      "purpose" string => "Set global class if the given regex matches a defined class";
      "field_0" string => "Class promiser";
      "field_1" string => "Regex for the function classmatch";
      "field_2" string => "Promisee";

   vars:
      "dim_class"
         comment => "Read data file for parsing.",
         handle  => "efl_class_classmatch_vars_files",
         int     => readstringarrayidx(
            "class_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "c"
         comment => "Get index array loaded above.",
         handle  => "efl_class_classmatch_vars_c",
         slist   => getindices( "class_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2" };

      "class[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${class_o[${c}][${c2}]}";

      "class_to_set[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][0]";
      "regex[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][1]";
      "promisee[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][2]";

   classes:
      "${${class_to_set[${c}]}}" -> { "${${promisee[${c}]}}" }
         comment    => "Set class if classmatch function returns true.",
         scope      => "namespace",
         expression => classmatch( "${${regex[${c}]}}" );
}

bundle agent efl_class_iprange( ref )
{
   meta:
      "purpose" string => "Set global class if host IP is within the given range";
      "field_0" string => "Class promiser";
      "field_1" string => "IP address range in the format of the iprange function.";
      "field_2" string => "Promisee";

   vars:
      "dim_class"
         comment => "Read data file for parsing.",
         handle  => "efl_class_iprange_vars_files",
         int     => readstringarrayidx(
            "class_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "c"
         comment => "Get index array loaded above.",
         handle  => "efl_class_iprange_vars_c",
         slist   => getindices( "class_o" );

      "c2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2" };

      "class[${c}][${c2}]"
         comment => "Work around for bug 2333",
         string => "${class_o[${c}][${c2}]}";

      "class_to_set[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][0]";
      "ip_range[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][1]";
      "promisee[${c}]"
         comment => "Turn into reference for simpler reading.",
         string  => "class[${c}][2]";

   classes:
      "${${class_to_set[${c}]}}" -> { "${${promisee[${c}]}}" }
         comment    => "Set class if iprange function returns true.",
         scope      => "namespace",
         expression => iprange( "${${ip_range[${c}]}}" );
}

bundle agent efl_class_hostname( ref )
#
# Reads parameter file in the form of <name>-<class>.txt.
# the file contains a list of unqualified hostnames separated by white space.
# If ${sys.uqhost} matches any name in the list <class> is defined.
{
   meta:
      "purpose" string => "Set global class if list item matches hostname";
      "field_0" string => "unqualified hostname";

   classes:
      "check_hostnames_${ref}"
         comment    => "Get class name from filename",
         expression => regextract( "${efl_c.class}", "${ref}", "class" );
      
      "${class[1]}"
         comment    => "Set class if unqualified hostname matches any list element.",
         scope      => "namespace",
         ifvarclass => canonify( "check_hostnames_${ref}" ),
         expression => regline( "${sys.uqhost}", "${ref}" );
}

body action efl_if_elapsed(x)
{
ifelapsed => "$(x)";
expireafter => "$(x)";
}
