# Copyright Evolve Thinking ( www.evolvethinking.com ).
# For fresh updates visit:
# https://github.com/evolvethinking/evolve_cfengine_freelib

#
# License
#
# Evolve_freelib.cf is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.  See the GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License along with
# this program.  If not, see <http://www.gnu.org/licenses/>.

#
# Introduction
#
# The bundles contained in this library primarily focus on content driven
# policy.  Each such bundle takes csv type delimited parameter file as shown in
# the common bundle efl_c. A record consists of a single line and the required
# fields.
#
# A skeleton bundle is provided for those that wish to create new bundles.

#
# Requirements
# 
# CFEngine Core 3.5.x or higher
# CFEengine standard library

bundle agent efl_skeleton ( ref )
{
   meta:
      "purpose" string => "Skeleton bundle for new bundle authoring";
      "field_0" string => "Context";

   vars:
      "dim_skel"
         comment => "Read data file for parsing.",
         handle  => "efl_skeleton_vars_files",
         int     => readstringarrayidx(
            "skel_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "f"
         comment => "Get index array loaded above.",
         handle  => "efl_skeleton_vars_f",
         slist   => getindices( "skel_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0" };
 
      "skel[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${skel_o[${f}][${f2}]}";

      "class[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "skel[${f}][0]";
# Call the above variable as ${${class[${f}]}} 
}

bundle agent efl_sysctl_live( ref )
{   
   meta:
      "purpose" string => "Promise live sysctl kernel settings";
      "field_0" string => "Context";
      "field_1" string => "sysctl variable";
      "field_2" string => "sysctl value";
      "field_3" string => "Promisee";

   vars:
      "params"   
         comment    => "Parameter field names and positions to be parsed.",
         data       => parsejson(
         '{
            "0" : "class",
            "1" : "variable",
            "2" : "value",
            "3" : "promisee"
         }');

      <efl param_parser efl/>

      "efl_sysctl_live[${d[${i}][variable]}]"
         comment    => "Get current live value",
         ifvarclass => "${d[${i}][class]}",
         string     => execresult(
            "${paths.path[sysctl]} -n ${d[${i}][variable]} |${paths.path[tr]} -d '\\n' | ${paths.path[tr]} '[:space:]' ' '",
            "useshell"
         );

   classes:
      <efl param_file_picker efl/>

      "set_live_sysctl_${d[${i}][variable]}"
         comment    => "Set class if live sysctl variable not equal to promised value",
         ifvarclass => "${d[${i}][class]}",
         not        => strcmp( "${d[${i}][value]}", "${efl_sysctl_live[${d[${i}][variable]}]}" );

      "${d[${i}][variable]}=${d[${i}][value]}_handle_efl_sysctl_live_classes_ok_kept"
         comment    => "Set class if live sysctl variable not equal to promised value",
         handle     => "efl_sysctl_live_classes_ok",
         scope      => "namespace",
         ifvarclass => "${d[${i}][class]}",
         expression => strcmp( "${d[${i}][value]}", "${efl_sysctl_live[${d[${i}][variable]}]}" );

   commands:
      "${paths.path[sysctl]} -w ${d[${i}][variable]}='${d[${i}][value]}'" -> { "${d[${i}][promisee]}" }
         comment    => "Set live sysctl variable",
         handle     => "efl_sysctl_live_commands_sysctl_w",
         classes    => efl_rkn( "${paths.path[sysctl]} -w ${d[${i}][variable]}='${d[${i}][value]}'", "efl_sysctl_live_commands_sysctl_w" ),
         action     => efl_delta_reporting( "efl_sysctl_live_commands_sysctl_w", "${paths.path[sysctl]} -w ${d[${i}][variable]}='${d[${i}][value]}'", "${d[${i}][promisee]}", "1" ),
         ifvarclass => canonify( "set_live_sysctl_${d[${i}][variable]}" ), 
         contain    => in_shell_and_silent;

   reports:
      delta_reporting::
         "efl_sysctl_live_classes_ok ;; ${d[${i}][variable]}=${d[${i}][value]} ;; ${d[${i}][promisee]}" -> { "${d[${i}][promisee]}" }
            handle         => "efl_sysctl_live_reports_log_promises",
            ifvarclass     => canonify( "${d[${i}][variable]}=${d[${i}][value]}_handle_efl_sysctl_live_classes_ok_kept" ),
            report_to_file => "${efl_c.promise_log}";
}

bundle agent efl_sysctl_conf_file( ref )
{
   meta:
      "purpose" string => "Promise live sysctl.conf.";
      "field_0" string => "Context";
      "field_1" string => "sysctl variable";
      "field_2" string => "sysctl value";
      "field_3" string => "Promisee";

   vars:
      "sysctl_conf"  string => "/etc/sysctl.conf";

      "params"   
         comment    => "Parameter field names and positions to be parsed.",
         data       => parsejson(
         '{
            "0" : "class",
            "1" : "variable",
            "2" : "value",
            "3" : "promisee"
         }');

      <efl param_parser efl/>

   classes:
      <efl param_file_picker efl/>

      "promise_sysctl_conf_for_${param_file}"
         comment    => "Ensure files promises are not evaluated prematurely.",
         expression => "${d[${i}][class]}";

   files:
      "${sysctl_conf}" -> { "Provisioning" }
         comment       => "Promise whole contents of sysctl.conf",
         handle        => "efl_sysctl_conf_file_files_contents",
         ifvarclass    => "promise_sysctl_conf_for_${param_file}",
         classes       => efl_rkn( "${sysctl_conf}", "efl_sysctl_conf_file_files_contents" ),
         action        => efl_delta_reporting( "efl_sysctl_conf_file_files_contents", "${sysctl_conf}", "Harending", "1" ),
         create        => "true",
         edit_defaults => empty,
         edit_line     => el_efl_sysctl_conf_file( "efl_sysctl_conf_file.d" );

      "${sysctl_conf}" -> { "Provisioning" }
         handle     => "efl_sysctl_conf_file_files_perms",
         ifvarclass => "promise_sysctl_conf_for_${param_file}",
         classes    => efl_rkn( "${sysctl_conf}", "efl_sysctl_conf_file_files_perms" ),
         action     => efl_delta_reporting( "efl_sysctl_conf_file_files_perms", "${sysctl_conf}", "Harending", "1" ),
         perms      => mog( "644", "root", "root" );
}

bundle edit_line el_efl_sysctl_conf_file( d )
{   
   vars:
      "i_unsorted"
         comment => "Get index array loaded above.",
         handle  => "el_efl_sysctl_conf_file_vars_x",
         slist   => getindices( "${d}" );

      "i"
         comment    => "Index data",
         slist      => sort( "i_unsorted", "int" );

   insert_lines:
      "${${d}[${i}][variable]} = ${${d}[${i}][value]}" -> { "${${d}[${i}][promisee]}" }
         handle     => "el_efl_sysctl_conf_file_insert_lines",
# TODO classes and actions do not seem to work in this bundle type.
         classes    => efl_rkn( "${${d}[${i}][variable]} = ${${d}[${i}][value]}", "el_efl_sysctl_conf_file_insert_lines" ),
         action     => efl_delta_reporting( "el_efl_sysctl_conf_file_insert_lines", "${${d}[${i}][variable]} = ${${d}[${i}][value]}", "${${d}[${i}][promisee]}", "1" ),
         ifvarclass => "${${d}[${i}][class]}";
}

bundle agent efl_command ( ref )
{
   meta:
      "purpose" string => "Run given command if context is true.";
      "field_0" string => "Context";
      "field_1" string => "Command";
      "field_2" string => "usehell";
      "field_3" string => "module";
      "field_4" string => "ifelapsed";
      "field_5" string => "promisee";

   vars:
     "params"   
         comment    => "Parameter field names and positions to be parsed.",
         data       => parsejson(
         '{
            "0" : "class",
            "1" : "command",
            "2" : "useshell",
            "3" : "module"
            "4" : "ifelapsed"
            "5" : "promisee"
         }');

      <efl param_parser efl/>

   classes:
      <efl param_file_picker efl/>

   commands:
      "${d[${i}][command]}" -> { "${d[${i}][promisee]}" }
         comment    => "Run desired command",
         handle     => "efl_command_commands",
         ifvarclass => "${d[${i}][class]}",
         contain    => contain_efl_command( "${d[${i}][useshell]}" ),
         module     => "${d[${i}][module]}",
         classes    => efl_rkn( "${d[${i}][command]}", "efl_command_commands" ),
         action     => efl_delta_reporting( "efl_command_commands", "${d[${i}][command]}", "${d[${i}][promisee]}", "${d[${i}][ifelapsed]}" );
}

body contain contain_efl_command ( useshell )
{
   useshell => "${useshell}";
}

bundle agent efl_link ( ref )
{
   meta:
      "purpose" string => "Link files if context is true.";
      "field_0" string => "Context";
      "field_1" string => "Link promiser";
      "field_2" string => "Link target";
      "field_3" string => "Link type";
      "field_4" string => "Promisee";

   vars:
     "params"   
         comment    => "Parameter field names and positions to be parsed.",
         data       => parsejson(
         '{
            "0" : "class",
            "1" : "link_name",
            "2" : "target",
            "3" : "link_type"
            "4" : "promisee"
         }');

      <efl param_parser efl/>

   classes:
      <efl param_file_picker efl/>

   files:
      "${d[${i}][link_name]}" -> { "${d[${i}][promisee]}" }
         comment           => "Make link if class is true",
         handle            => "efl_link_files_target",
         ifvarclass        => "${d[${i}][class]}",
         move_obstructions => 'true',
         classes           => efl_rkn( "${d[${i}][link_name]}", "efl_link_files_target" ),
         action            => efl_delta_reporting( "efl_link_files_target", "${d[${i}][link_name]}", "${d[${i}][promisee]}", "1" ),
         link_from         => efl_source_type( "${d[${i}][target]}", "${d[${i}][link_type]}" );
}

body link_from efl_source_type ( source, type )
{
   source         => "${source}";
   link_type      => "${type}";
   when_no_source => "force";
}

bundle agent efl_delete_files ( ref )
{
   meta:
      "purpose" string => "Delete files that match the given criteria.";
      "field_0" string => "Context";
      "field_1" string => "Files promiser";
      "field_2" string => "Recurse no/#/inf";
      "field_3" string => "Leaf regex";
      "field_4" string => "Negative match yes/no";
      "field_5" string => "File age in days";
      "field_6" string => "Promisee";

   vars:
      "dim_files"
         comment => "Read data file for parsing.",
         handle  => "efl_delete_files_vars_files",
         int     => readstringarrayidx(
            "files_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "f"
         comment => "Get index array loaded above.",
         handle  => "efl_delete_files_vars_f",
         slist   => getindices( "files_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6" };

      "files[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string  => "${files_o[${f}][${f2}]}";

      "files[${f}][file_canon]"
         comment    => "Canonify file name fo later use",
         string     => canonify( "${files[${f}][1]}" );

      "class[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][0]";
      "file[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][1]";
      "file_canon[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][file_canon]";
      "recurse[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][2]";
      "leaf[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][3]";
      "negate[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][4]";
      "age[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][5]";
      "promisee[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][6]";

   classes:
# TODO test this
# These classes are defined in order to simply ifvarclass usage later. Ifvarclass
# can be buggy when used in conjunction with functions.

        "${${file_canon[${f}]}}_${f}_positive_match"
            ifvarclass => "${${class[${f}]}}",
            expression => strcmp( "no", "${${negate[${f}]}}" );

        "${${file_canon[${f}]}}_${f}_negative_match"
            ifvarclass => "${${class[${f}]}}",
            expression => strcmp( "yes", "${${negate[${f}]}}" );

        "${${file_canon[${f}]}}_${f}_is_file"
            ifvarclass => "${${class[${f}]}}",
            or         => { isplain( "${${file[${f}]}}" ), islink( "${${file[${f}]}}" ) };

        "${${file_canon[${f}]}}_${f}_is_dir"
            ifvarclass => "${${class[${f}]}}",
            expression => isdir( "${${file[${f}]}}" );

        "${${file_canon[${f}]}}_${f}_is_file_and_positive_match"
            and => { "${${file_canon[${f}]}}_${f}_is_file", "${${file_canon[${f}]}}_${f}_positive_match" };

        "${${file_canon[${f}]}}_${f}_is_file_and_negative_match"
            and => { "${${file_canon[${f}]}}_${f}_is_file", "${${file_canon[${f}]}}_${f}_negative_match" };

        "${${file_canon[${f}]}}_${f}_is_dir_and_positive_match"
            and => { "${${file_canon[${f}]}}_${f}_is_dir", "${${file_canon[${f}]}}_${f}_positive_match" };

        "${${file_canon[${f}]}}_${f}_is_dir_and_negative_match"
            and => { "${${file_canon[${f}]}}_${f}_is_dir", "${${file_canon[${f}]}}_${f}_negative_match" };

   files:
      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment      => "Delete files recursively",
         handle       => "efl_delete_files_files_isdir",
         classes      => efl_rkn( "${${file[${f}]}}", "efl_delete_files_files_isdir" ),
         action       => efl_delta_reporting( "efl_delete_files_files_isdir", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass   => "${${file_canon[${f}]}}_${f}_is_dir_and_positive_match",
         depth_search => recurse( "${${recurse[${f}]}}" ),
         file_select  => name_age( "${${leaf[${f}]}}", "${${age[${f}]}}" ),
         delete       => tidy;

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment      => "Delete files",
         handle       => "efl_delete_files_files_single",
         classes      => efl_rkn( "${${file[${f}]}}", "efl_delete_files_files_single" ),
         action       => efl_delta_reporting( "efl_delete_files_files_single", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass   => "${${file_canon[${f}]}}_${f}_is_file_and_positive_match",
         file_select  => name_age( "${${leaf[${f}]}}", "${${age[${f}]}}" ),
         delete       => tidy;

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment      => "Delete files recursively excluding leaf name.",
         handle       => "efl_delete_files_files_isdir_negative",
         classes      => efl_rkn( "${${file[${f}]}}", "efl_delete_files_files_isdir_negative" ),
         action       => efl_delta_reporting( "efl_delete_files_files_isdir_negative", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass   => "${${file_canon[${f}]}}_${f}_is_dir_and_negative_match",
         depth_search => recurse( "${${recurse[${f}]}}" ),
         file_select  => name_age_negate( "${${leaf[${f}]}}", "${${age[${f}]}}" ),
         delete       => tidy;

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment      => "Delete files, excluding leaf name",
         handle       => "efl_delete_files_files_single_negative",
         classes      => efl_rkn( "${${file[${f}]}}", "efl_delete_files_files_single_negative" ),
         action       => efl_delta_reporting( "efl_delete_files_files_single_negative", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass   => "${${file_canon[${f}]}}_${f}_is_file_and_negative_match",
         file_select  => name_age_negate( "${${leaf[${f}]}}", "${${age[${f}]}}" ),
         delete       => tidy;
}

body file_select name_age_negate(name,days)
{
leaf_name   => { "$(name)" };
mtime       => irange(0,ago(0,0,"$(days)",0,0,0));
file_result => "mtime.!leaf_name";
}

bundle agent efl_copy_files ( ref )
{
   meta:
      "purpose" string => "Copy files";
      "field_0" string => "Context";
      "field_1" string => "File promiser. A trailing /. indicates a directory for recursive copy.";
      "field_2" string => "leaf regex";
      "field_3" string => "File source";
      "field_4" string => "Server";
      "field_5" string => "Encrypt transfer";
      "field_6" string => "file mode";
      "field_7" string => "file owner";
      "field_8" string => "file group";
      "field_9" string => "Promisee";

   vars:
      "dim_files"
         comment => "Read data file for parsing.",
         handle  => "efl_copy_files_vars_files",
         int     => readstringarrayidx(
            "files_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "f"
         comment => "Get index array loaded above.",
         handle  => "efl_copy_files_vars_f",
         slist   => getindices( "files_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9" };

      "files[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${files_o[${f}][${f2}]}";

      "files[${f}][file_canon]"
         comment    => "Canonify file name fo later use",
         string     => canonify( "${files[${f}][1]}" );

      "class[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][0]";
      "file_canon[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][file_canon]";
      "file[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][1]";
      "leaf[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][2]";
      "source[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][3]";
      "server[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][4]";
      "encrypt[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][5]";
      "mode[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][6]";
      "owner[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][7]";
      "group[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][8]";
      "promisee[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][9]";

   classes:
      "recurse_${${file_canon[${f}]}}_${f}"
         comment    => "Set if promiser is a directory",
         ifvarclass => "${${class[${f}]}}",
         expression => regcmp( ".+/\.", "${${file[${f}]}}" );

      "no_recurse_${${file_canon[${f}]}}_${f}"
         comment    => "Set if promiser is a directory",
         ifvarclass => "${${class[${f}]}}",
         not        => regcmp( ".+/\.", "${${file[${f}]}}" );
      
   files:
      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         handle     => "efl_copy_files_create_dir",
         comment    => "Create promiser directory",
         ifvarclass => "recurse_${${file_canon[${f}]}}_${f}",
         create     => 'true';

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Copy a single file",
         handle     => "efl_copy_files_single",
         create     => 'true',
         ifvarclass => "no_recurse_${${file_canon[${f}]}}_${f}",
         classes    => efl_rkn( "${${file[${f}]}}", "efl_copy_files_remote_single" ),
         action     => efl_delta_reporting( "efl_copy_files_remote_single", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         copy_from  => efl_cpf( "${${source[${f}]}}", "@{${${server[${f}]}}}", "${${encrypt[${f}]}}" );

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment      => "Copy and recurse",
         handle       => "efl_copy_files_recurse",
         create       => 'true',
         classes      => efl_rkn( "${${file[${f}]}}", "efl_copy_files_remove_recurse" ),
         action       => efl_delta_reporting( "efl_copy_files_remove_recurse", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass   => "recurse_${${file_canon[${f}]}}_${f}",
         depth_search => recurse( "inf" ),
         file_select  => by_name( "${${leaf[${f}]}}" ),
         copy_from    => efl_cpf( "${${source[${f}]}}", "@{${${server[${f}]}}}", "${${encrypt[${f}]}}" );

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Promise permissions and ownership",
         handle     => "efl_copy_files_single_perms",
         classes    => efl_rkn( "${${file[${f}]}}", "efl_copy_files_single_perms" ),
         action     => efl_delta_reporting( "efl_copy_files_single_perms", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass => "no_recurse_${${file_canon[${f}]}}_${f}",
         perms      => mog( "${${mode[${f}]}}", "${${owner[${f}]}}", "${${group[${f}]}}" );

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment      => "Promise permissions and ownership",
         handle       => "efl_copy_files_recurse_perms",
         classes      => efl_rkn( "${${file[${f}]}}", "efl_copy_files_recurse_perms" ),
         action       => efl_delta_reporting( "efl_copy_files_recurse_perms", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass   => "recurse_${${file_canon[${f}]}}_${f}",
         depth_search => recurse( "inf" ),
         file_select  => by_name( "${${leaf[${f}]}}" ),
         perms        => mog( "${${mode[${f}]}}", "${${owner[${f}]}}", "${${group[${f}]}}" );
}

body copy_from efl_cpf(from, server, encrypt)
{
   servers     => { "${server}" };
   source      => "${from}";
   encrypt     => "${encrypt}";
   compare     => "digest";
}

bundle agent efl_packages_via_cmd( ref )
{
   meta:
      'Purpose' string => "promise packages using commands promises";
      "field_0" string => "Context";
      "field_1" string => "Package policy";
      "field_2" string => "Package name regex";
      'field_3' string => "Full version string or '0' for latest";
      "field_4" string => "arch, '*' seems to work to imply any arch";
      "field_5" string => "promisee";

   vars:
      "dim_packages"
         comment => "Read data to be used in method promises.",
         int     => readstringarrayidx(
            "pack_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
            );

      "i" slist => getindices( "pack_o" );

      "i2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5" };

      "pack[${i}][${i2}]"
         comment => "Work around for bug 2333",
         string => "${pack_o[${i}][${i2}]}";

## Make refernces for simpler reading
      "class[${i}]"    string => "pack[${i}][0]";
      "policy[${i}]"   string => "pack[${i}][1]";
      "name[${i}]"     string => "pack[${i}][2]";
      "version[${i}]"  string => "pack[${i}][3]";
      "arch[${i}]"     string => "pack[${i}][4]";
      "promisee[${i}]" string => "pack[${i}][5]";

      debian::
         "package_mgr" string => "/usr/bin/apt-get";
         "install"     string => "install";
         "remove"      string => "remove";
         "switches"    string => "-y";
         "name_spec[${i}]" string  => "'${${name[${i}]}}=${${version[${i}]}}'";
 
      redhat::
         "package_mgr" string => "/usr/bin/yum";
         "install"     string => "install";
         "remove"      string => "remove";
         "switches"    string => "-y";
         "name_spec[${i}]" string  => "'${${name[${i}]}}-${${version[${i}]}}'";
 
   classes:
      "without_version_${i}"
         ifvarclass => "${${class[${i}]}}",
         expression => strcmp( "0", "${${version[${i}]}}" );

      "with_version_${i}"
         ifvarclass => "${${class[${i}]}}",
         not        => strcmp( "0", "${${version[${i}]}}" );

      "install_package_${i}"
         ifvarclass => "${${class[${i}]}}",
         expression => regcmp( "install|add|addupdate", "${${policy[${i}]}}" );

      "remove_package_${i}"
         ifvarclass => "${${class[${i}]}}",
         expression => regcmp( "remove|delete", "${${policy[${i}]}}" );

# Cannot specify version regex. So, must specify exact version or no version.
# If no version then install must not have '=ver'.
   commands:
      "${package_mgr} ${install} ${switches} '${name_spec[${i}]}'" -> { '${${promisee[${i}]}}' }
         comment    => 'Install package',
         handle     => 'efl_packages_via_cmd_commands_install_version',
         ifvarclass => 'install_package_${i}.with_version_${i}',
         classes    => efl_rkn(
            "${package_mgr} ${install} ${switches} '${name_spec[${i}]}'",
            'efl_packages_via_cmd_commands_install_version' ),
         action     => efl_delta_reporting( 'efl_packages_via_cmd_commands_install_version',
            "${package_mgr} ${install} ${switches} '${name_spec[${i}]}'",
            '${${promisee[${i}]}}', '1' );

      "${package_mgr} ${install} ${switches} '${${name[${i}]}}'" -> { '${${promisee[${i}]}}' }
         comment    => 'Install package',
         handle     => 'efl_packages_via_cmd_commands_install_no_version',
         ifvarclass => 'install_package_${i}.without_version_${i}',
         classes    => efl_rkn(
            "${package_mgr} ${install} ${switches} '${${name[${i}]}}'",
            'efl_packages_via_cmd_commands_install_no_version' ),
         action     => efl_delta_reporting( 'efl_packages_via_cmd_commands_install_no_version',
            "${package_mgr} ${install} ${switches} '${${name[${i}]}}'",
            '${${promisee[${i}]}}', '1' );

      "${package_mgr} ${remove} ${switches} '${${name[${i}]}}'" -> { '${${promisee[${i}]}}' }
         comment    => 'Remove package',
         handle     => 'efl_packages_via_cmd_commands_remove',
         ifvarclass => 'remove_package_${i}',
         classes    => efl_rkn(
            "${package_mgr} ${remove} ${switches} '${${name[${i}]}}'",
            'efl_packages_via_cmd_commands_remove' ),
         action     => efl_delta_reporting( 'efl_packages_via_cmd_commands_remove',
            "${package_mgr} ${remove} ${switches} '${${name[${i}]}}'",
            '${${promisee[${i}]}}', '1' );
}

bundle agent efl_packages( ref )
{
   meta:
      "purpose" string => "Promises packages using generic method.";
      "field_0" string => "Context";
      "field_1" string => "Package policy";
      "field_2" string => "Package name regex";
      "field_3" string => "version string";
      "field_4" string => "arch, '*' seems to work to imply any arch";
      "field_5" string => "promisee";
      "ReadMe"  string => "Specify a version of '0' when version does not matter.";

   vars:
      "dim_pkg"
         comment => "Read data file for parsing.",
         handle  => "efl_packages_vars_files",
         int     => readstringarrayidx(
            "pkg_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "p"
         comment => "Get index array loaded above.",
         handle  => "efl_packages_vars_p",
         slist   => getindices( "pkg_o" );

      "p2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5" };

      "pkg[${p}][${p2}]"
         comment => "Work around for bug 2333",
         string => "${pkg_o[${p}][${p2}]}";

      "class[${p}]"
         comment => "Turn into reference for simpler reading.",
         string  => "pkg[${p}][0]";
      "policy[${p}]"
         comment => "Turn into reference for simpler reading.",
         string  => "pkg[${p}][1]";
      "name[${p}]"
         comment => "Turn into reference for simpler reading.",
         string  => "pkg[${p}][2]";
      "version[${p}]"
         comment => "Turn into reference for simpler reading.",
         string  => "pkg[${p}][3]";
      "arch[${p}]"
         comment => "Turn into reference for simpler reading.",
         string  => "pkg[${p}][4]";
      "promisee[${p}]"
         comment => "Turn into reference for simpler reading.",
         string  => "pkg[${p}][5]";

   classes:
      "do_not_specify_version_${p}"
         comment    => "If version is '0' then do not specify version string",
         ifvarclass => "${${class[${p}]}}",
         expression => strcmp( "${${version[${p}]}}", "0" );

      "specify_version_${p}"
         comment    => "If version is not '0' then specify version string",
         ifvarclass => "${${class[${p}]}}",
         not        => strcmp( "${${version[${p}]}}", "0" );

   packages:
      "${${name[${p}]}}" -> { "${${promisee[${p}]}}" }
         comment               => "Promise package without version.",
         handle                => "efl_packages_packages_generic_no_version",
         classes               => efl_rkn( "${${name[${p}]}}", "efl_packages_packages_generic_no_version" ),
         action                => efl_delta_reporting( "efl_packages_packages_generic_no_version", "${${name[${p}]}}", "${${promisee[${p}]}}", "1" ),
         ifvarclass            => "do_not_specify_version_${p}",
         package_policy        => "${${policy[${p}]}}",
         package_method        => generic,
         package_architectures => { "${${arch[${p}]}}" };

      "${${name[${p}]}}" -> { "${${promisee[${p}]}}" }
         comment               => "Promise package with version.",
         handle                => "efl_packages_packages_generic_version",
         classes               => efl_rkn( "${${name[${p}]}}", "efl_packages_packages_generic_version" ),
         action                => efl_delta_reporting( "efl_packages_packages_generic_version", "${${name[${p}]}}", "${${promisee[${p}]}}", "1" ),
         ifvarclass            => "specify_version_${p}",
         package_policy        => "${${policy[${p}]}}",
         package_method        => generic,
         package_version       => "${${version[${p}]}}",
         package_architectures => { "${${arch[${p}]}}" };
}

bundle agent efl_start_service ( ref )
{
   meta:
      "purpose" string => "Start serivce with process and restart command.";
      "field_0" string => "Context";
      "field_1" string => "Process regex";
      "field_2" string => "Restart command";
      "field_3" string => "Promisee";

   vars:
      "dim_svc"
         comment => "Read data file for parsing.",
         handle  => "efl_start_service_vars_files",
         int     => readstringarrayidx(
            "svc_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "s"
         comment => "Get index array loaded above.",
         handle  => "efl_start_service_vars_s",
         slist   => getindices( "svc_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3" };

      "svc[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string => "${svc_o[${s}][${s2}]}";

      "class[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][0]";
      "process[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][1]";
      "command[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][2]";
      "promisee[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][3]";

   processes:
      "${${process[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment        => "Promise process is running",
         handle         => "efl_start_service_processes_proc",
         process_select => by_command( "${${process[${s}]}}" ),
         classes        => efl_rkn( "${${process[${s}]}}", "efl_start_service_processes_proc" ),
         action         => efl_delta_reporting( "efl_start_service_processes_proc", "${${process[${s}]}}", "${${promisee[${s}]}}", "1" ),
         ifvarclass     => "${${class[${s}]}}",
         restart_class  => canonify( "efl_start_service_command_${${process[${s}]}}_${s}" );

   commands:
      "${${command[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment    => "Restart service is required.",
         handle     => "efl_start_service_commands_restart",
         classes    => efl_rkn( "${${command[${s}]}}", "efl_start_service_commands_restart" ),
         action     => efl_delta_reporting( "efl_start_service_commands_restart", "${${command[${s}]}}", "${${promisee[${s}]}}", "1" ),
         contain    => in_shell_and_silent,
         ifvarclass => canonify( "efl_start_service_command_${${process[${s}]}}_${s}" );
}

bundle agent efl_service_recurse ( ref )
{
   meta:
      "purpose"  string => "Promise serivce with recursive file, process, and restart command.";
      "field_0"  string => "Context";
      "field_1"  string => "Process regex";
      "field_2"  string => "Promiser directory";
      "field_3"  string => "Source directory";
      "field_4"  string => "Source server, as list without syntax: efl_c.policy_servers";
      "field_5"  string => "Encrypted copy yes/now";
      "field_6"  string => "Configuration file mode";
      "field_7"  string => "Configuration file owner";
      "field_8"  string => "Configuration file group";
      "field_9"  string => "Restart command";
      "field_10" string => "Promisee";

   vars:
      "dim_svc"
         comment => "Read data file for parsing.",
         int     => readstringarrayidx(
            "svc_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "s"
         comment => "Get index array loaded above.",
         handle  => "efl_service_vars_s",
         slist   => getindices( "svc_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10" };

      "svc[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string => "${svc_o[${s}][${s2}]}";

      ## Use references for simpler reading.",
      "class[${s}]"              string  => "svc[${s}][0]";
      "process[${s}]"            string  => "svc[${s}][1]";
      "promiser_directory[${s}]" string  => "svc[${s}][2]";
      "source_directory[${s}]"   string  => "svc[${s}][3]";
      "server[${s}]"             string  => "svc[${s}][4]";
      "encrypt[${s}]"            string  => "svc[${s}][5]";
      "mode[${s}]"               string  => "svc[${s}][6]";
      "user[${s}]"               string  => "svc[${s}][7]";
      "group[${s}]"              string  => "svc[${s}][8]";
      "command[${s}]"            string  => "svc[${s}][9]";
      "promisee[${s}]"           string  => "svc[${s}][10]";

   files:
      "${efl_c.cache}/${${promiser_directory[${s}]}}/." -> { "${${promisee[${s}]}}" }
         comment    => "Create cache dir",
         handle     => "efl_service_recurse_cache_dir",
         ifvarclass => "${${class[${s}]}}",
         create     => "true",
         classes    => efl_rkn( "${efl_c.cache}/${${promiser_directory[${s}]}}/.",
            "efl_service_recurse_cache_dir" ),
         action     => efl_delta_reporting( "efl_service_recurse_cache_dir",
            "${efl_c.cache}/${${promiser_directory[${s}]}}/.", "${${promisee[${s}]}}", "1"
         );

      "${efl_c.cache}/${${promiser_directory[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment      => "Copy cache",
         handle       => "efl_service_recurse_copy_cache",
         ifvarclass   => "${${class[${s}]}}",
         classes      => efl_rkn( "${efl_c.cache}/${${promiser_directory[${s}]}}",
            "efl_service_recurse_copy_cache" ),
         action       => efl_delta_reporting( "efl_service_recurse_copy_cache",
            "${efl_c.cache}/${${promiser_directory[${s}]}}", "${${promisee[${s}]}}", "1"
         ),
         depth_search => recurse( "inf" ),
         copy_from    => efl_cpf( "${${source_directory[${s}]}}", "@{${${server[${s}]}}}", "${${encrypt[${s}]}}" );

      "${efl_c.cache}/${${promiser_directory[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment      => "Perms for cache of source file",
         handle       => "efl_service_recurse_cache_perms",
         ifvarclass   => "${${class[${s}]}}",
         classes      => efl_rkn( "${efl_c.cache}/${${promiser_directory[${s}]}}",
            "efl_service_recurse_cache_perms" ),
         action       => efl_delta_reporting( "efl_service_recurse_cache_perms",
            "${efl_c.cache}/${${promiser_directory[${s}]}}", "${${promisee[${s}]}}", "1"
         ),
         depth_search => recurse( "inf" ),
         perms        => mog( "${${mode[${s}]}}", "${${user[${s}]}}", "${${group[${s}]}}" );

      "${${promiser_directory[${s}]}}/." -> { "${${promisee[${s}]}}" }
         comment    => "Create dir",
         handle     => "efl_service_recurse_dir",
         ifvarclass => "${${class[${s}]}}",
         create     => "true",
         classes    => efl_rkn( "${${promiser_directory[${s}]}}/.",
            "efl_service_recurse_dir" ),
         action     => efl_delta_reporting( "efl_service_recurse_dir",
            "${${promiser_directory[${s}]}}/.", "${${promisee[${s}]}}", "1"
         );

      "${${promiser_directory[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment      => "Copy to final destination",
         handle       => "efl_service_recurse_copy",
         ifvarclass   => "${${class[${s}]}}",
         classes      => efl_rkn( "${${promiser_directory[${s}]}}",
            "efl_service_recurse_copy" ),
         action       => efl_delta_reporting( "efl_service_recurse_copy",
            "${${promiser_directory[${s}]}}", "${${promisee[${s}]}}", "1"
         ),
         depth_search => recurse( "inf" ),
         copy_from    => efl_cpf(
            "${efl_c.cache}/${${promiser_directory[${s}]}}",
            "localhost", "${${encrypt[${s}]}}"
         );

      "${${promiser_directory[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment      => "Perms for destination files",
         handle       => "efl_service_recurse_files_perms",
         ifvarclass   => "${${class[${s}]}}",
         classes      => efl_rkn( "${${promiser_directory[${s}]}}",
            "efl_service_recurse_perms" ),
         action       => efl_delta_reporting( "efl_service_recurse_perms",
            "${${promiser_directory[${s}]}}", "${${promisee[${s}]}}", "1"
         ),
         depth_search => recurse( "inf" ),
         perms        => mog( "${${mode[${s}]}}", "${${user[${s}]}}", "${${group[${s}]}}" );

   processes:
      "${${process[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment        => "Promise process is running",
         handle         => "efl_service_recurse_processes_proc",
         classes        => efl_rkn( "${${process[${s}]}}", "efl_service_recurse_processes_proc" ),
         action         => efl_delta_reporting( "efl_service_recurse_processes_proc", "${${process[${s}]}}", "${${promisee[${s}]}}", "1" ),
         process_select => by_command( "${${process[${s}]}}" ),
         ifvarclass     => "${${class[${s}]}}",
         restart_class  => "restart_proc_${s}";

   commands:
      "${${command[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment    => "Restart service is required.",
         handle     => "efl_service_recurse_commands_restart",
         classes    => efl_rkn( "${${command[${s}]}}", "efl_service_recurse_commands_restart" ),
         action     => efl_delta_reporting( "efl_service_recurse_commands_restart", "${${command[${s}]}}", "${${promisee[${s}]}}", "1" ),
         contain    => in_shell_and_silent,
         ifvarclass => or(
            "restart_proc_${s}",
            canonify( "${${promiser_directory[${s}]}}_handle_efl_service_recurse_copy_repaired" )
         );
}

bundle agent efl_service ( ref )
{
   meta:
      "purpose"  string => "Promise serivce with file, process, and restart command.";
      "field_0"  string => "Context";
      "field_1"  string => "Process regex";
      "field_2"  string => "Configuration file promiser";
      "field_3"  string => "Configuration file source";
      "field_4"  string => "Source server, as list without syntax: efl_c.policy_servers";
      "field_5"  string => "Template file yes/no";
      "field_6"  string => "Encrypted copy yes/now";
      "field_7"  string => "Configuration file mode";
      "field_8"  string => "Configuration file owner";
      "field_9"  string => "Configuration file group";
      "field_10" string => "Restart command";
      "field_11" string => "Promisee";

   vars:
      "dim_svc"
         comment => "Read data file for parsing.",
         int     => readstringarrayidx(
            "svc_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "s"
         comment => "Get index array loaded above.",
         slist   => getindices( "svc_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11" };

      "svc[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string => "${svc_o[${s}][${s2}]}";

      "class[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][0]";
      "process[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][1]";
      "config_file[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][2]";
      "source_file[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][3]";
      "server[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][4]";
      "template[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][5]";
      "encrypt[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][6]";
      "mode[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][7]";
      "user[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][8]";
      "group[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][9]";
      "command[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][10]";
      "promisee[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][11]";

   classes:
      "copy_config_${${source_file[${s}]}}_${s}" 
         comment    => "If configuration file is a straight copy",
         ifvarclass => "${${class[${s}]}}",
         expression => strcmp( "${${template[${s}]}}", "no" );

      "build_from_template_${${source_file[${s}]}}_${s}"
         comment    => "If configuration file is a template",
         ifvarclass => "${${class[${s}]}}",
         expression => strcmp( "${${template[${s}]}}", "yes" );

   files:
      "${efl_c.cache}/${${config_file[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment    => "Cache the source file",
         handle     => "efl_service_files_cache",
         classes    => efl_rkn( "${efl_c.cache}/${${config_file[${s}]}}", "efl_service_svc_cache" ),
         action     => efl_delta_reporting( "efl_service_svc_cache", "${efl_c.cache}/${${config_file[${s}]}}", "${${promisee[${s}]}}", "1" ),
         ifvarclass => "${${class[${s}]}}",
         create     => "true",
         copy_from  => efl_cpf( "${${source_file[${s}]}}", "@{${${server[${s}]}}}", "${${encrypt[${s}]}}" );

      "${efl_c.cache}/${${config_file[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment    => "Perms for cache of source file",
         handle     => "efl_service_files_cache_perms",
         classes    => efl_rkn( "${efl_c.cache}/${${config_file[${s}]}}", "efl_service_svc_cache_perms" ),
         action     => efl_delta_reporting( "efl_service_svc_cache_perms", "${efl_c.cache}/${${config_file[${s}]}}", "${${promisee[${s}]}}", "1" ),
         ifvarclass => "${${class[${s}]}}",
         perms      => mog( "${${mode[${s}]}}", "${${user[${s}]}}", "${${group[${s}]}}" );

      "${${config_file[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment    => "Promise contents of configuration file",
         handle     => "efl_service_files_config",
         classes    => efl_rkn( "${${config_file[${s}]}}", "efl_service_files_config" ),
         action     => efl_delta_reporting( "efl_service_files_config", "${${config_file[${s}]}}", "${${promisee[${s}]}}", "1" ),
         ifvarclass => canonify( "copy_config_${${source_file[${s}]}}_${s}" ),
         create     => "true",
         copy_from  => efl_cpf( "${efl_c.cache}/${${config_file[${s}]}}", "localhost", "${${encrypt[${s}]}}" );

      "${${config_file[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment       => "Promise contents of configurationn file from template",
         handle        => "efl_service_files_config_template",
         classes       => efl_rkn( "${${config_file[${s}]}}", "efl_service_files_config_template" ),
         action        => efl_delta_reporting( "efl_service_files_config_template", "${${config_file[${s}]}}", "${${promisee[${s}]}}", "1" ),
         create        => "true",
         edit_defaults => empty,
         ifvarclass    => canonify( "build_from_template_${${source_file[${s}]}}_${s}" ),
         edit_template => "${efl_c.cache}/${${config_file[${s}]}}";

      "${${config_file[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment    => "Promise permissions of configuration file",
         handle     => "efl_service_files_config_permissions",
         classes    => efl_rkn( "${${config_file[${s}]}}", "efl_service_files_config_permissions" ),
         action     => efl_delta_reporting( "efl_service_files_config_permissions", "${${config_file[${s}]}}", "${${promisee[${s}]}}", "1" ),
         ifvarclass => "${${class[${s}]}}",
         perms      => mog( "${${mode[${s}]}}", "${${user[${s}]}}", "${${group[${s}]}}" );

   processes:
      "${${process[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment        => "Promise process is running",
         handle         => "efl_service_processes_proc",
         classes        => efl_rkn( "${${process[${s}]}}", "efl_service_processes_proc" ),
         action         => efl_delta_reporting( "efl_service_processes_proc", "${${process[${s}]}}", "${${promisee[${s}]}}", "1" ),
         process_select => by_command( "${${process[${s}]}}" ),
         ifvarclass     => "${${class[${s}]}}",
         restart_class  => canonify( "efl_service_command_${${command[${s}]}}" );

   commands:
      "${${command[${s}]}}" -> { "${${promisee[${s}]}}" }
         comment    => "Restart service is required.",
         handle     => "efl_service_commands_restart",
         classes    => efl_rkn( "${${command[${s}]}}", "efl_service_commands_restart" ),
         action     => efl_delta_reporting( "efl_service_commands_restart", "${${command[${s}]}}", "${${promisee[${s}]}}", "1" ),
         contain    => in_shell_and_silent,
         ifvarclass => or(
               canonify( "efl_service_command_${${command[${s}]}}" ),
               canonify( "${${config_file[${s}]}}_handle_efl_service_files_config_repaired" ),
               canonify( "${${config_file[${s}]}}_handle_efl_service_files_config_template_repaired" )
               );
}

body process_select by_command( command )
{
	command        => "${command}";
	process_result => "command";
}

bundle agent efl_chkconfig_enable_service ( ref )
{
   meta:
      "purpose" string => "Enable service boot using chkconfig.";
      "field_0" string => "Context";
      "field_1" string => "Service name promiser";
      "field_2" string => "Promisee";

   vars:
      debian::
         "chkconfig_check"
            comment => "Check mode required for Debian's chkconfig",
            string  => "${paths.path[chkconfig]} -c";

      !debian::
         "chkconfig_check"
            comment => "Check mode not required for none Debian",
            string  => "${paths.path[chkconfig]}";

      any::
         "dim_svc"
            comment => "Read data file for parsing.",
            handle  => "efl_chkconfig_enable_service_vars_files",
            int     => readstringarrayidx(
               "svc_o",
               "${ref}",
               "${efl_c.comment}",
               "${efl_c.array_delimiter}",
               "${efl_c.max_num}",
               "${efl_c.max_bytes}"
            );

         "s"
            comment => "Get index array loaded above.",
            handle  => "efl_chkconfig_enable_service_vars_s",
            slist   => getindices( "svc_o" );

      "s2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2" };

      "svc[${s}][${s2}]"
         comment => "Work around for bug 2333",
         string => "${svc_o[${s}][${s2}]}";

      "class[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][0]";
      "service[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][1]";
      "promisee[${s}]"
         comment => "Turn into reference for simpler reading.",
         string  => "svc[${s}][2]";

   classes:
      _stdlib_path_exists_chkconfig::
         "efl_chkconfig_enable_${${service[${s}]}}"
            comment    => "Check if service is enabled",
            handle     => "efl_chkconfig_enable_classes_needs_repair",
            ifvarclass => "${${class[${s}]}}",
            not        => returnszero( "${chkconfig_check} ${${service[${s}]}}", "noshell" );

         "${${service[${s}]}}_handle_efl_chkconfig_enable_classes_ok_kept"
            comment    => "Check if service is enabled",
            handle     => "efl_chkconfig_enable_classes_ok",
            scope      => "namespace",
            ifvarclass => "${${class[${s}]}}",
            expression => returnszero( "${chkconfig_check} ${${service[${s}]}}", "noshell" );

   commands:
      "${paths.path[chkconfig]} ${${service[${s}]}} on" -> { "${${promisee[${s}]}}" }
         comment    => "Enable service using chkconfig",
         handle     => "efl_chkconfig_enable_service_commands_chkconfig",
         ifvarclass => canonify( "efl_chkconfig_enable_${${service[${s}]}}" ),
         classes    => efl_rkn( "${paths.path[chkconfig]} ${${service[${s}]}} off", "efl_chkconfig_enable_service_commands_chkconfig" ),
         action     => efl_delta_reporting( "efl_chkconfig_enable_service_commands_chkconfig", "${${service[${s}]}}", "${${promisee[${s}]}}", "1" ),
         contain    => silent;

   reports:
      delta_reporting::
         "${efl_c.udate} ;; efl_chkconfig_enable_classes_ok ;; ${${service[${s}]}} ;; ${${promisee[${s}]}}"
            ifvarclass      => canonify( "${${service[${s}]}}_handle_efl_chkconfig_enable_classes_ok_kept" ),
            report_to_file  => "${efl_c.promise_log}";

      !_stdlib_path_exists_chkconfig::
         "Promise ${this.handle} reports ${paths.path[chkconfig]} is not found."
            handle => "efl_chkconfig_enable_service_reports_no_chkconfig";

}

bundle agent efl_chkconfig_disable_service ( ref )
{
   meta:
      "purpose" string => "Disable service boot using chkconfig.";
      "field_0" string => "Context";
      "field_1" string => "Service name promiser";
      "field_2" string => "Promisee";

   vars:
      debian::
         "chkconfig_check"
            comment => "Check mode required for Debian's chkconfig",
            string  => "${paths.path[chkconfig]} -c";

      !debian::
         "chkconfig_check"
            comment => "Check mode not required for none Debian",
            string  => "${paths.path[chkconfig]}";

      any::
         "dim_svc"
            comment => "Read data file for parsing.",
            handle  => "efl_chkconfig_disable_service_vars_files",
            int     => readstringarrayidx(
               "svc_o",
               "${ref}",
               "${efl_c.comment}",
               "${efl_c.array_delimiter}",
               "${efl_c.max_num}",
               "${efl_c.max_bytes}"
            );

         "s"
            comment => "Get index array loaded above.",
            handle  => "efl_chkconfig_disable_service_vars_s",
            slist   => getindices( "svc_o" );

         "s2"
            comment => "Work around for bug 2333",
            slist => { "0", "1", "2" };

         "svc[${s}][${s2}]"
            comment => "Work around for bug 2333",
            string => "${svc_o[${s}][${s2}]}";

         "class[${s}]"
            comment => "Turn into reference for simpler reading.",
            string  => "svc[${s}][0]";
         "service[${s}]"
            comment => "Turn into reference for simpler reading.",
            string  => "svc[${s}][1]";
         "promisee[${s}]"
            comment => "Turn into reference for simpler reading.",
            string  => "svc[${s}][2]";

   classes:
      _stdlib_path_exists_chkconfig::
         "efl_chkconfig_disable_${${service[${s}]}}"
            comment    => "Check if service is enabled",
            handle     => "efl_chkconfig_disable_classes_needs_repair",
            ifvarclass => "${${class[${s}]}}",
            expression => returnszero( "${chkconfig_check} ${${service[${s}]}}", "noshell" );

         "${${service[${s}]}}_handle_efl_chkconfig_disable_classes_ok_kept"
            comment    => "Check if service is enabled",
            handle     => "efl_chkconfig_disable_classes_ok",
            scope      => "namespace",
            ifvarclass => "${${class[${s}]}}",
            not        => returnszero( "${chkconfig_check} ${${service[${s}]}}", "noshell" );

   commands:
      "${paths.path[chkconfig]} ${${service[${s}]}} off" -> { "${${promisee[${s}]}}" }
         comment    => "Enable service using chkconfig",
         handle     => "efl_chkconfig_disable_service_commands_chkconfig",
         ifvarclass => canonify( "efl_chkconfig_disable_${${service[${s}]}}" ),
         classes    => efl_rkn( "${paths.path[chkconfig]} ${${service[${s}]}} off", "efl_chkconfig_disable_service_commands_chkconfig" ),
         action     => efl_delta_reporting( "efl_chkconfig_disable_service_commands_chkconfig", "${${service[${s}]}}", "${${promisee[${s}]}}", "1" ),
         contain    => silent;

   reports:
      delta_reporting::
         "${efl_c.udate} ;; efl_chkconfig_disable_classes_ok ;; ${${service[${s}]}} ;; ${${promisee[${s}]}}"
            ifvarclass      => canonify( "${${service[${s}]}}_handle_efl_chkconfig_disable_classes_ok_kept" ),
            report_to_file  => "${efl_c.promise_log}";

      !_stdlib_path_exists_chkconfig::
         "Promise ${this.handle} reports ${paths.path[chkconfig]} is not found."
            handle => "efl_chkconfig_disable_service_reports_no_chkconfig";
}

bundle agent efl_file_perms ( ref )
{
   meta:
      "purpose" string => "Promise file permissions.";
      "field_0" string => "Context";
      "field_1" string => "Promiser file";
      "field_2" string => "Recurse into promiser directory no/#/inf)";
      "field_3" string => "Leaf regex";
      "field_4" string => "Negative match?";
      "field_5" string => "Promiser mode";
      "field_6" string => "Promiser owner";
      "field_7" string => "Promiser group";
      "field_8" string => "Promisee";

   vars:
      "dim_files"
         comment => "Read data file for parsing.",
         handle  => "efl_file_perms_vars_files",
         int     => readstringarrayidx(
            "files_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "f"
         comment => "Get index array loaded above.",
         handle  => "efl_file_perms_vars_f",
         slist   => getindices( "files_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6", "7", "8" };

      "files[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${files_o[${f}][${f2}]}";

      "files[${f}][file_canon]"
         comment    => "Canonify file name fo later use",
         string     => canonify( "${files[${f}][1]}" );

      "class[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][0]";
      "file[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][1]";
      "file_canon[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][file_canon]";
      "recurse[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][2]";
      "leaf[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][3]";
      "negative[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][4]";
      "mode[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][5]";
      "user[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][6]";
      "group[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][7]";
      "promisee[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][8]";

      classes:
         "recurse_${${file_canon[${f}]}}_${f}"
            comment    => "Is recursion desired?",
            ifvarclass => "${${class[${f}]}}",
            expression => strcmp( "yes", "${${recurse[${f}]}}" );
         
         "do_not_recurse_${${file_canon[${f}]}}_${f}"
            comment    => "Is recursion desired?",
            ifvarclass => "${${class[${f}]}}",
            expression => strcmp( "no", "${${recurse[${f}]}}" );
         
         "negative_match_${${file_canon[${f}]}}_${f}"
            comment => "Is negative match desired?",
            ifvarclass => "${${class[${f}]}}",
            expression => strcmp( "yes", "${${negative[${f}]}}" );

         "positive_match_${${file_canon[${f}]}}_${f}"
            comment => "Is positive match desired?",
            ifvarclass => "${${class[${f}]}}",
            expression => strcmp( "no", "${${negative[${f}]}}" );

         "recurse_and_negative_match_${${file_canon[${f}]}}_${f}"
            and => { "recurse_${${file_canon[${f}]}}_${f}", "negative_match_${${file_canon[${f}]}}_${f}" };

         "recurse_and_positive_match_${${file_canon[${f}]}}_${f}"
            and => { "recurse_${${file_canon[${f}]}}_${f}", "positive_match_${${file_canon[${f}]}}_${f}" };

         "do_not_recurse_and_negative_match_${${file_canon[${f}]}}_${f}"
            and => { "do_not_recurse_${${file_canon[${f}]}}_${f}", "negative_match_${${file_canon[${f}]}}_${f}" };

         "do_not_recurse_and_positive_match_${${file_canon[${f}]}}_${f}"
            and => { "do_not_recurse_${${file_canon[${f}]}}_${f}", "positive_match_${${file_canon[${f}]}}_${f}" };

      files:
         "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
            comment      => "Promise permissions of file recurse_with_base and positive match",
            handle       => "efl_file_perms_files_recurse_with_base_postive",
            ifvarclass   => "recurse_and_positive_match_${${file_canon[${f}]}}_${f}",
            classes      => efl_rkn( "${${file[${f}]}}", "efl_file_perms_files_recurse_with_base_postive" ),
            action       => efl_delta_reporting( "efl_file_perms_files_recurse_with_base_postive", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
            depth_search => recurse_with_base( "${${recurse[${f}]}}" ),
            file_select  => by_name( "${${leaf[${f}]}}" ),
            perms        => mog( "${${mode[${f}]}}", "${${user[${f}]}}", "${${group[${f}]}}" );

         "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
            comment      => "Promise permissions of file recurse_with_base and negative leaf match",
            handle       => "efl_file_perms_files_recurse_with_base_negative",
            ifvarclass   => "recurse_and_positive_match_${${file_canon[${f}]}}_${f}",
            classes      => efl_rkn( "${${file[${f}]}}", "efl_file_perms_files_recurse_with_base_negative" ),
            action       => efl_delta_reporting( "efl_file_perms_files_recurse_with_base_negative", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
            depth_search => recurse_with_base( "${${recurse[${f}]}}" ),
            file_select  => negate_by_name( "${${leaf[${f}]}}" ),
            perms        => mog( "${${mode[${f}]}}", "${${user[${f}]}}", "${${group[${f}]}}" );

         "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
            comment      => "Promise permissions using positive match",
            handle       => "efl_file_perms_files_positive",
            ifvarclass   => "do_not_recurse_and_negative_match_${${file_canon[${f}]}}_${f}",
            classes      => efl_rkn( "${${file[${f}]}}", "efl_file_perms_files_positive" ),
            action       => efl_delta_reporting( "efl_file_perms_files_positive", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
            file_select  => by_name( "${${leaf[${f}]}}" ),
            perms        => mog( "${${mode[${f}]}}", "${${user[${f}]}}", "${${group[${f}]}}" );

         "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
            comment      => "Promise permissions using negative leaf match",
            handle       => "efl_file_perms_files_negative",
            ifvarclass   => "do_not_recurse_and_positive_match_${${file_canon[${f}]}}_${f}",
            classes      => efl_rkn( "${${file[${f}]}}", "efl_file_perms_files_negative" ),
            action       => efl_delta_reporting( "efl_file_perms_files_negative", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
            file_select  => negate_by_name( "${${leaf[${f}]}}" ),
            perms        => mog( "${${mode[${f}]}}", "${${user[${f}]}}", "${${group[${f}]}}" );
}

body file_select negate_by_name(names)
{
   leaf_name  => { @(names)};
   file_result => "!leaf_name";
}

bundle agent efl_edit_template ( ref )
{
   meta:
      "purpose" string => "Promise whole contents of files";
      "field_0" string => "Class or context";
      "field_1" string => "Promiser file";
      "field_2" string => "Source file";
      "field_3" string => "Mode";
      "field_4" string => "User";
      "field_5" string => "Group";
      "field_6" string => "Promisee";

   vars:
      "dim_files"
         comment => "Read data file for parsing.",
         handle  => "efl_edit_template_vars_files",
         int     => readstringarrayidx(
            "files_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "f"
         comment => "Get index array loaded above.",
         handle  => "efl_edit_template_vars_f",
         slist   => getindices( "files_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6", "7", "8" };

      "files[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${files_o[${f}][${f2}]}";

      "class[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][0]";
      "file[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][1]";
      "source[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][2]";
      "mode[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][3]";
      "user[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][4]";
      "group[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][5]";
      "promisee[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "files[${f}][6]";

   files:
      "${efl_c.cache}/${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Locally cache template file.",
         handle     => "efl_edit_template_cache_template",
         classes    => efl_rkn( "${efl_c.cache}/${${file[${f}]}}", "efl_edit_template_cache_template" ),
         action     => efl_delta_reporting( "efl_edit_template_cache_template", "${efl_c.cache}/${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass => "${${class[${f}]}}",
         create     => "true",
         copy_from  => remote_dcp( "${${source[${f}]}}", "@{efl_global_slists.policy_servers}" );

      "${efl_c.cache}/${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Perms for locally cache template file.",
         handle     => "efl_edit_template_cache_template_perms",
         classes    => efl_rkn( "${efl_c.cache}/${${file[${f}]}}", "efl_edit_template_cache_template_perms" ),
         action     => efl_delta_reporting( "efl_edit_template_cache_template_perms", "${efl_c.cache}/${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass => "${${class[${f}]}}",
         perms      => mog( "${${mode[${f}]}}", "${${user[${f}]}}", "${${group[${f}]}}" );

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment       => "Promise contents of file",
         handle        => "efl_edit_template_files_promiser",
         classes       => efl_rkn( "${${file[${f}]}}", "efl_edit_template_files_promiser" ),
         action        => efl_delta_reporting( "efl_edit_template_files_promiser", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass    => "${${class[${f}]}}",
         create        => "true",
         edit_defaults => empty,
         edit_template => "${efl_c.cache}/${${file[${f}]}}";

      "${${file[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Promise permissions of file",
         handle     => "efl_edit_template_files_perms",
         classes    => efl_rkn( "${${file[${f}]}}", "efl_edit_template_files_perms" ),
         action     => efl_delta_reporting( "efl_edit_template_files_perms", "${${file[${f}]}}", "${${promisee[${f}]}}", "1" ),
         ifvarclass => "${${class[${f}]}}",
         perms      => mog( "${${mode[${f}]}}", "${${user[${f}]}}", "${${group[${f}]}}" );
}

bundle agent efl_lastseen
{
   meta:
      'purpose' string => "Report agents that have checked in, in the past 24 hours";

   vars:
      'hours'
         comment => "Last seen horizon in hours",
         int     => '24';

      'last_seen_hosts'
         comment => "Make list of addresses seen within the given hours",
         slist   => hostsseen( "${hours}", "lastseen", "address" );

   reports:
      cfengine::
         "${last_seen_hosts}"
            handle => "efl_lastseen_reports_hosts";
}

bundle agent efl_notseen
{
   meta:
      'purpose' string => "Report agents that have not checked in, in the past 24 hours";

   vars:
      'hours'
         comment => "Not seen within the last x hours",
         int     => '24';

      'last_seen_hosts'
         comment => "Make list of addresses not seen within the given hours",
         slist   => hostsseen( "${hours}", "notseen", "address" );

   reports:
      cfengine::
         "${last_seen_hosts}"
            handle => "efl_notseen_reports_hosts";
}

bundle agent efl_mon_cfengine
{
    meta:
        "purpose" string => "Report Cfengine connections stats from cf-monitord";

    reports:
        cfengine::
           "Current inbound connections: ${mon.value_cfengine_in}";
           "Average number of inbound connections per 5min: ${mon.av_cfengine_in}";
           "Standard deviation: ${mon.dev_cfengine_in}";
           "Current outbound connections: ${mon.value_cfengine_out}";
           "Average number of outbound connections per 5min: ${mon.av_cfengine_out}";
           "Standard deviation: ${mon.dev_cfengine_out}";
}

bundle server efl_server
{
   meta:
      "purpose" string => "Read cf-server access rules.";
      "field_0" string => "Context";
      "field_1" string => "Promiser path";
      "field_2" string => "Comma separated admit list";
      "field_3" string => "Promisee";

   vars:
      "dim_acl"
         comment => "Read data file for parsing.",
         handle  => "efl_server_vars_files",
         int     => readstringarrayidx(
            "acl_o",
            "${efl_c.efl_server_txt}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "f"
         comment => "Get index array loaded above.",
         handle  => "efl_server_vars_f",
         slist   => getindices( "acl_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist   => { "0","1","2","3" };
 
      "acl[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string  => "${acl_o[${f}][${f2}]}";

      "class[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "acl[${f}][0]";
      "path[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "acl[${f}][1]";
      "admit[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "acl[${f}][2]";
      "promisee[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "acl[${f}][3]";

      "acl_list[${f}]"
         comment => "Turn comma list into slist",
         slist   => splitstring( "${${admit[${f}]}}", "\s*,\s*", "10" );

   access:

      "${${path[${f}]}}" -> { "${${promisee[${f}]}}" }
            handle     => "efl_server_grant_access_policy",
            comment    => "Grant client access to the policy server",
            ifvarclass => "${${class[${f}]}}",
            admit      => { "@{acl_list[${f}]}" };
}

body action efl_delta_reporting ( handle, promiser, promisee, if_elapsed )
{
   ifelapsed => "${if_elapsed}";

   upassive::
      action_policy => 'warn';

   delta_reporting::
      log_kept     => "${efl_c.promise_log}";
      log_repaired => "${efl_c.promise_log}";
      log_failed   => "${efl_c.promise_log}";
      log_string   => "${handle} ;; ${promiser} ;; ${promisee}";
# Remove date due to CFEngine bug 3441
      #log_string   => "${efl_c.udate} ;; ${handle} ;; ${promiser} ;; ${promisee}";
}

body classes efl_rkn( promiser, handle )
{
      promise_kept      => { "${promiser}_handle_${handle}_kept" };
      promise_repaired  => { "${promiser}_handle_${handle}_repaired" };
      repair_failed     => { "${promiser}_handle_${handle}_notkept" };
      repair_denied     => { "${promiser}_handle_${handle}_notkept" };
      repair_timeout    => { "${promiser}_handle_${handle}_notkept" };
}

bundle agent efl_bug3430 (ref)
{
   meta:
      "purpose" string => "Workaround CFEngine tcdb corruption and deadlock issues";
      "readme"  string => "See bug https://cfengine.com/dev/issues/3430";

   vars:
      redhat::
         "lsof" string => "/usr/sbin/lsof";

      debian::
         "lsof" string => "/usr/bin/lsof";

      any::
         "cf_lock_tcdb"
            comment => "Location of lock database",
            string  => "${sys.workdir}/state/cf_lock.tcdb";

         "cf_lock_tcdb_lock"
            comment => "Location of lock database",
            string  => "${cf_lock_tcdb}.lock";

         "lsof_pids_string"
            comment => "Count number of openings to cf_lock.tcdb",
            string  => execresult( "${lsof} -t ${cf_lock_tcdb_lock}", "noshell" );

         "lsof_pids"
            comment => "Convert string to list",
            slist   => splitstring( "${lsof_pids_string}", "\s+", "10" );

         "no_of_pids"
            comment => "Convert string returned from execresult to int",
            int     => length( "lsof_pids" );

   classes:
      "kill_pids"
         expression => isgreaterthan( "${no_of_pids}", "1" );

      "delete_cf_lock"
         expression => "cf_agent_handle_efl_bug3430_processes_kill_cf_agent_repaired";

      "report_kill_and_delete"
         expression => classmatch( ".*?_handle_efl_bug3430.*?_repaired" );

   files:
      delete_cf_lock::
         "${cf_lock_tcdb}" -> { "CFEngine bug 3430" }
            comment => "Remove corrupted lock file",
            handle  => "efl_bug3430_files_delete_cf_lock_tcdb",
            classes => efl_rkn( "${cf_lock_tcdb}", "efl_bug3430_files_delete_cf_lock_tcdb" ),
            action  => efl_delta_reporting( "efl_bug3430_files_delete_cf_lock_tcdb", "${cf_lock_tcdb}", "CFEngine bug 3430", "1" ),
            delete  => tidy;

   processes:
      kill_pids::
         "cf-agent" -> { "CFEngine bug 3430" }
            comment        => "Kill pids",
            handle         => "efl_bug3430_processes_kill_cf_agent",
            signals        => { "term", "kill" },
            classes        => efl_rkn( "cf-agent", "efl_bug3430_processes_kill_cf_agent" ),
            action         => efl_delta_reporting( "efl_bug3430_processes_kill_cf_agent", "cf-agent", "CFEngine bug 3430", "1" ),
            process_select => by_pid( "${lsof_pids}" );

   reports:
      report_kill_and_delete::
         "TCDB corruption detected. Repair was attempted.";
}

bundle agent efl_rcs_pull( ref )
{
   meta:
      "purpose" string => "Build or update a copy from version control";
      "field_0" string => "Context";
      "field_1" string => "Update working copy command";
# Example: /usr/bin/git reset --hard HEAD && /usr/bin/git pull
      "field_2" string => "Checkout command to be used if update command fails";
# Example: /usr/bin/git clone https://github.com/evolvethinking/evolve_cfengine_freelib.git
      "field_3" string => "Destination directory, or your working directory";
      "field_4" string => "Mode for destination directory.";
      "field_5" string => "Owner";
      "field_6" string => "Group";
      "field_7" string => "Promisee";

   vars:
      "dim_rcs"
         comment => "Read data file for parsing.",
         handle  => "efl_rcs_pull_vars_files",
         int     => readstringarrayidx(
            "rcs_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "f"
         comment => "Get index array loaded above.",
         handle  => "efl_rcs_pull_vars_f",
         slist   => getindices( "rcs_o" );

      "f2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3", "4", "5", "6", "7" };
 
      "rcs[${f}][${f2}]"
         comment => "Work around for bug 2333",
         string => "${rcs_o[${f}][${f2}]}";

      "class[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][0]";
      "update[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][1]";
      "checkout[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][2]";
      "dir[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][3]";
      "mode[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][4]";
      "owner[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][5]";
      "group[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][6]";
      "promisee[${f}]"
         comment => "Turn into reference for simpler reading.",
         string  => "rcs[${f}][7]";

      "canonify[${f}]"
         comment => "Canonify for later use",
         string  => canonify( "PROMISER=${f} ${${update[${f}]}}" );

      classes:
         "promise_permissions_${f}"
            comment => "Fix perms if update or checkout was made",
            or => {
               "${canonify[${f}]}_handle_efl_rcs_pull_commands_update_repaired",
               "${canonify[${f}]}_handle_efl_rcs_pull_commands_checkout_repaired",
               "${canonify[${f}]}_handle_efl_rcs_pull_commands_update_kept",
               "${canonify[${f}]}_handle_efl_rcs_pull_commands_checkout_kept"
            };

   files:
      "${${dir[${f}]}}/." -> { "${${promisee[${f}]}}" }
         comment    => "Create destination directory",
         handle     => "efl_rcs_pull_files_create_dir",
         ifvarclass => "${${class[${f}]}}",
         classes    => efl_rkn( "${${dir[${f}]}}", "efl_rcs_pull_files_create_dir" ),
         action     => efl_delta_reporting( "efl_rcs_pull_files_create_dir", "${${dir[${f}]}}", "${${promisee[${f}]}}", "1" ),
         create     => 'true';

      "${${dir[${f}]}}/." -> { "${${promisee[${f}]}}" }
         comment    => "promise directory perms",
         handle     => "efl_rcs_pull_files_dir_perms",
         ifvarclass => "${${class[${f}]}}",
         classes    => efl_rkn( "${${dir[${f}]}}", "efl_rcs_pull_files_dir_perms" ),
         action     => efl_delta_reporting( "efl_rcs_pull_files_dir_perms", "${${dir[${f}]}}", "${${promisee[${f}]}}", "1" ),
         perms      => mog( "${${mode[${f}]}}", "${${owner[${f}]}}", "${${group[${f}]}}" );

      "${${dir[${f}]}}/." -> { "${${promisee[${f}]}}" }
         comment      => "promise perms on contents",
         handle       => "efl_rcs_pull_files_perms",
         ifvarclass   => "promise_permissions_${f}",
         classes      => efl_rkn( "${${dir[${f}]}}", "efl_rcs_pull_files_perms" ),
         action       => efl_delta_reporting( "efl_rcs_pull_files_perms", "${${dir[${f}]}}", "${${promisee[${f}]}}", "1" ),
         depth_search => recurse( "inf" ),
         file_select  => by_name( ".*" ),
         perms        => og( "${${owner[${f}]}}", "${${group[${f}]}}" );

      "${${dir[${f}]}}/" -> { "${${promisee[${f}]}}" }
         comment      => "purge destination directory if update command failed",
         handle       => "efl_rcs_files_purge_dir",
         ifvarclass   => canonify( "PROMISER=${f} ${${update[${f}]}}_handle_efl_rcs_pull_commands_update_notkept" ),
         delete       => tidy,
         depth_search => recurse( "inf" ),
         file_select  => by_name( ".*" ),
         classes      => efl_rkn( "${${dir[${f}]}}", "efl_rcs_files_purge_dir" ),
         action       => efl_delta_reporting( "efl_rcs_files_purge_dir", "${${dir[${f}]}}", "${${promisee[${f}]}}", "1" );

   commands:
      "PROMISER=${f} ${${checkout[${f}]}} ${${dir[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Pull checkout",
         handle     => "efl_rcs_pull_commands_checkout",
         ifvarclass => canonify( "PROMISER=${f} ${${update[${f}]}}_handle_efl_rcs_pull_commands_update_notkept" ),
         contain    => in_dir_shell_and_silent( "${${dir[${f}]}}" ),
         classes    => efl_rkn( "PROMISER=${f} ${${checkout[${f}]}}", "efl_rcs_pull_commands_checkout" ),
         action     => efl_delta_reporting( "efl_rcs_pull_commands_checkout", "PROMISER=${f} ${${checkout[${f}]}}", "${${promisee[${f}]}}", "1" );

      "PROMISER=${f} ${${update[${f}]}}" -> { "${${promisee[${f}]}}" }
         comment    => "Pull update",
         handle     => "efl_rcs_pull_commands_update",
         ifvarclass => "${${class[${f}]}}",
         contain    => in_dir_shell_and_silent( "${${dir[${f}]}}" ),
         classes    => efl_rkn( "PROMISER=${f} ${${update[${f}]}}", "efl_rcs_pull_commands_update" ),
         action     => efl_delta_reporting( "efl_rcs_pull_commands_update", "PROMISER=${f} ${${update[${f}]}}", "${${promisee[${f}]}}", "1" );
}

bundle agent efl_test_simple( ref )
{
   meta:
      "purpose" string => "A testing bundle inspired by Perl's Test::Simple";
      "field_0" string => "Context expression"; # class
      "field_1" string => "Class regex to test"; # class_to_test
      "field_2" string => "pass test whether test class 'is' true or 'isnt' true"; # is_or_isnt
      "field_3" string => "Test name, free form like promisee"; # name

   vars:
     "params"   
         comment    => "Parameter field names and positions to be parsed.",
         data       => parsejson(
         '{
            "0" : "class",
            "1" : "class_to_test",
            "2" : "is_or_isnt",
            "3" : "name",
         }');

      <efl param_parser efl/>

   classes:
      <efl param_file_picker efl/>

      "class_isnt_${d[${i}][class_to_test]}"
        ifvarclass => "${d[${i}][class]}",
        expression => strcmp( "isnt", "${d[${i}][is_or_isnt]}" );
      "class_is_${d[${i}][class_to_test]}"
        ifvarclass => "${d[${i}][class]}",
        expression => strcmp( "is", "${d[${i}][is_or_isnt]}" );

      "pass_${d[${i}][class_to_test]}"
         ifvarclass => "class_isnt_${d[${i}][class_to_test]}",
         not        => "${d[${i}][class_to_test]}";
      "fail_${d[${i}][class_to_test]}"
         ifvarclass => "class_isnt_${d[${i}][class_to_test]}",
         expression => "${d[${i}][class_to_test]}";
      "pass_${d[${i}][class_to_test]}"
         ifvarclass => "class_is_${d[${i}][class_to_test]}",
         expression => "${d[${i}][class_to_test]}";
      "fail_${d[${i}][class_to_test]}"
         ifvarclass => "class_is_${d[${i}][class_to_test]}",
         not        => "${d[${i}][class_to_test]}";

   reports:
      "PASS, ${d[${i}][class_to_test]}, ${d[${i}][name]}"
         ifvarclass => "pass_${d[${i}][class_to_test]}";
      "FAIL, ${d[${i}][class_to_test]}, ${d[${i}][name]}"
         ifvarclass => "fail_${d[${i}][class_to_test]}";

      efl_test_simple_debug::
         "${d[${i}][class]}, ${d[${i}][class_to_test]}, ${d[${i}][is_or_isnt]}, ${d[${i}][name]}";
}

bundle agent efl_dump_strings( ref )
{
   meta:
      "purpose" string => "Dump string variables via reports promises";
      "field_0" string => "Context expression"; # class
      "field_1" string => "Name of string to dump"; # name
      "field_2" string => "promisee"; # promisee

   vars:
     "params"   
         comment    => "Parameter field names and positions to be parsed.",
         data       => parsejson(
         '{
            "0" : "class",
            "1" : "name",
            "2" : "promisee",
         }');

      <efl param_parser efl/>

   classes:
      <efl param_file_picker efl/>

   reports:
      "Name => [${d[${i}][name]}] Value => [${${d[${i}][name]}}] Promisee => [${d[${i}][promisee]}]"
         ifvarclass => "${d[${i}][class]}";

}

bundle agent efl_test_count( ref )
{
   meta:
      "purpose" string => "Skeleton bundle for new bundle authoring";
      "field_0" string => "Context expression";
      "field_1" string => "Class regex to test";
      "field_2" string => "Expected number classes that match the regex";
      "field_3" string => "Test name, free form like promisee";

   vars:
      "dim_test"
         comment => "Read data file for parsing.",
         handle  => "efl_test_count_vars_files",
         int     => readstringarrayidx(
            "test_o",
            "${ref}",
            "${efl_c.comment}",
            "${efl_c.array_delimiter}",
            "${efl_c.max_num}",
            "${efl_c.max_bytes}"
         );

      "i"
         comment => "Get index array loaded above.",
         handle  => "efl_test_count_vars_i",
         slist   => getindices( "test_o" );

      "i2"
         comment => "Work around for bug 2333",
         slist => { "0", "1", "2", "3" };
 
      "test[${i}][${i2}]"
         comment => "Work around for bug 2333",
         string => "${test_o[${i}][${i2}]}";

      "class[${i}]"
         comment => "Turn into reference for simpler reading.",
         string  => "test[${i}][0]";
      "test_class[${i}]"
         comment => "Turn into reference for simpler reading.",
         string  => "test[${i}][1]";
      "count[${i}]"
         comment => "Turn into reference for simpler reading.",
         string  => "test[${i}][2]";
      "test_name[${i}]"
         comment => "Turn into reference for simpler reading.",
         string  => "test[${i}][3]";

      "count_${i}"
         comment    => "Count number of classes matching regex test_class",
         ifvarclass => "${${class[${i}]}}",
         int        => countclassesmatching( "${${test_class[${i}]}}" );

   classes:
      "pass_${i}"
         ifvarclass => "${${class[${i}]}}",
         expression => strcmp( "${count_${i}}", "${${count[${i}]}}" );
      "fail_${i}"
         ifvarclass => "${${class[${i}]}}",
         not        => strcmp( "${count_${i}}", "${${count[${i}]}}" );

   reports:
      "PASS, [${${test_class[${i}]}}], [${${test_name[${i}]}}]"
         ifvarclass => "pass_${i}";
      "FAIL, [${${test_class[${i}]}}], [${${test_name[${i}]}}], expected [${${count[${i}]}}], got [${count_${i}}]"
         ifvarclass => "fail_${i}";

      efl_test_count_debug::
         "[${${class[${i}]}}], [${${test_class[${i}]}}], [${${count[${i}]}}], [${${test_name[${i}]}}]";
}
